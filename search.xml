<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ZooKeeper相关概念</title>
    <url>/2020/09/30/ZooKeeper%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>ZooKeeper是一个分布式、开源的分布式应用程序协调服务，它公开了一组简单的原语，分布式应用程序可以基于这些原语来实现更高级别的同步、配置维护、组和命名服务。ZooKeeper目的是减轻分布式应用程序从零开始实现协调服务的任务。本文基于3.6.2版本。<a id="more"></a></p>
<h3 id="数据模型，Data-Model"><a href="#数据模型，Data-Model" class="headerlink" title="数据模型，Data Model"></a>数据模型，Data Model</h3><p>ZooKeeper有个分层命名空间，就像是一棵树，每个节点能够关联数据，节点的路径都是绝对路径，不允许使用相对路径。关于路径命名还有一些要求：</p>
<ul>
<li>“zookeeper”是保留字，不允许使用</li>
<li>“.” 和 “..” 可以作为命名的一部分，但不允许单独使用，如”a/./b”是不被允许的</li>
</ul>
<h4 id="ZNodes"><a href="#ZNodes" class="headerlink" title="ZNodes"></a>ZNodes</h4><p>ZooKeeper中的节点被称为znode，znode会维护一个stat结构，其中包括数据更改与ACL更改的版本号，时间戳，有了版本号和时间戳，ZooKeeper能够去验证缓存和协调更新。版本号会随着znode数据的更改而增长，当客户端获取数据时也会获取到数据的版本号，当客户端对数据进行更新或删除操作时，ZooKeeper会对版本号进行比对验证，若不匹配则操作失败。</p>
<p>Znode是程序员访问的主要实体，它们有几个值得一提的特点：</p>
<ul>
<li>监听机制，客户端可以对znode进行监听，当znode发生改变时会触发监听器并且清除监听器，监听器一旦被触发，客户端会收到一个通知。</li>
<li>每个znode上的数据读写都是具有原子性的，每个节点都会有一个ACL（访问控制列表）来限制谁可以做什么。</li>
<li>ZooKeeper并不适合存储大量数据，它被设计来管理协调性数据，这些数据可以是配置、状态信息等，它们相对较小，以千字节为单位，如果非得在ZooKeeper中大容量存储数据，可以将数据存储在其他大容量存储系统中，并在ZooKeeper中存储指向数据存储位置的指针。ZooKeeper一开始的设计目的就不是为了存储大容量数据，而是为了协调数据，还会对节点的数据进行管理，使每个节点的数据不会超过1M。</li>
<li>临时节点，Ephemeral Nodes，只要创建临时节点的会话还存在，临时节点就会存在，当会话结束时，临时节点则会被删除，所以<strong>临时节点不允许有子节点</strong>。会话的临时节点列表可以通过<code>getEphemerals()</code>进行获取。</li>
<li>唯一命名，当创建节点时，ZooKeeper可以在节点路径的最后加上一个单调递增的计数器，该计数器对该节点的父节点来说是唯一的，计数器的格式为10位数字，填充0，例如“0000000001”，计数器为4字节有符号整数，当超过2147483647时会溢出。</li>
<li>容器节点，Container Nodes，在3.6.0版本加入，当容器节点的最后一个子节点被删除，那么该容器节点在未来的某个时刻将被服务端删除。考虑到这个属性，当创建容器节点的子节点时可能会出现<code>KeeperException.NoNodeException</code>异常，此时应该重新创建父容器节点。</li>
<li>TTL节点，在3.6.0版本加入，可以为节点设置一个以毫秒为单位的TTL，当在TTL时间内节点没有被更改，那么该节点在未来的某个时刻将被删除。TTL节点默认是禁用状态，需要在系统属性中启用。</li>
</ul>
<h4 id="ZooKeeper中的时间"><a href="#ZooKeeper中的时间" class="headerlink" title="ZooKeeper中的时间"></a>ZooKeeper中的时间</h4><ul>
<li><strong>Zxid</strong>，ZooKeeper使用的时间戳，ZooKeeper状态的每次改变都会收到一个zxid形式的时间戳，每次更改都会有唯一的zxid，当zxid1小于zxid2时，说明zxid1在zxid2前发生。</li>
<li><strong>版本号</strong>，每个节点都会有自己的版本号，节点发生变化时版本号会递增，有三个版本号：version（znode数据的更改次数）、cversion（znode子节点的更改次数）、aversion（znode的ACL更改次数）。</li>
<li><strong>心跳时间</strong>，当使用多服务器ZooKeeper时，服务器使用心跳来定义事件的时间，例如状态上传、会话超时、连接超时等，心跳时间间接公开了最小会话时间，最小会话时间是两倍心跳时间，如果客户端请求会话的时间小于最小会话时间，那么服务端会告诉客户端请求会话的时间就是最小会话时间。</li>
<li><strong>真实时间</strong>，ZooKeeper不会使用真实时间，除了在创建或修改节点时需要在stat结构中放入时间戳。</li>
</ul>
<h4 id="Stat-结构"><a href="#Stat-结构" class="headerlink" title="Stat 结构"></a>Stat 结构</h4><p>每个节点都会有stat结构，它包含：</p>
<ul>
<li><strong>czxid</strong>，该节点被创建时所生成的zxid</li>
<li><strong>mzxid</strong>，该节点上一次被修改时所生成的zxid</li>
<li><strong>pzxid</strong>，该节点上一次被修改的子节点所生成的zxid</li>
<li><strong>ctime</strong>，该节点被创建时的时间戳，以毫秒为单位</li>
<li><strong>mtime</strong>，该节点上一次被修改时的时间戳，以毫秒为单位</li>
<li><strong>version</strong>，该节点的数据的更改次数</li>
<li><strong>cversion</strong>，该节点的子节点的更改次数</li>
<li><strong>aversion</strong>，该节点的ACL更改次数</li>
<li><strong>ephemeralOwner</strong>，该临时节点所属的session id，若不是临时节点，则为0</li>
<li><strong>dataLength</strong>，该节点数据字段的长度</li>
<li><strong>numChildren</strong>，该节点的子节点数量</li>
</ul>
<h3 id="会话，Sessions"><a href="#会话，Sessions" class="headerlink" title="会话，Sessions"></a>会话，Sessions</h3><p>客户端和服务端通过创建句柄的方式来进行连接，就是会话，会话一旦建立成功，状态就是<code>CONNECTING</code>（连接中），然后客户端就会尝试去连接服务端，连接成功后状态会变为<code>CONNECTED</code>（已连接），正常情况下只会有这两种状态。如果发生不可恢复的错误，例如会话过期、身份验证失败或者客户端关闭连接，那么session状态会变为<code>CLOSE</code>（关闭）。下图是会话状态的转换过程。</p>
<p><img src="/2020/09/30/ZooKeeper%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg" alt="会话状态转换"></p>
<p>为了创建一个会话，代码中必须提供一个逗号<code>,</code>分隔的字符串，例如：<code>127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002</code>，包含<code>host:port</code>，客户端会任意选择一个服务端进行连接，如果连接失败或者因为某些原因连接断开，那么客户端会重新连接下一个服务端，直到连接成功。</p>
<h4 id="3-2-0版本新增特性"><a href="#3-2-0版本新增特性" class="headerlink" title="3.2.0版本新增特性"></a>3.2.0版本新增特性</h4><p>3.2.0版本新增特性：可以选择在连接字符串增加一个<code>chroot</code>后缀，例如：<code>127.0.0.1:4545/app/a</code>，在这种情况下，我们访问的<code>/foo/bar</code>其实是ZooKeeper服务端的<code>/app/a/foo/bar</code>节点。</p>
<p>3.2.0版本新增特性：<code>SessionMovedException</code>异常，这是一个内部异常，一般不会被应有程序接触到，发生此异常是因为在另一个服务端上重新建立会话连接的时候收到了请求。例如，一个客户端向服务端A发送请求，但因为网络延迟，所以该客户端超时并连接到新的服务端B，当延迟的数据包到达服务端A时，服务端A会检测到会话已移动，并关闭客户端连接，客户端通常不会看到此错误，因为它们不从那些旧连接中读取数据。还有个比较特殊的情况，当两个客户端尝试使用保存的会话id和密码重新建立同一个服务端时，会出现客户端A重新建立连接，客户端B断开连接，紧接着客户端B就会重连，导致客户端A断开连接，这样会导致这两个客户端尝试无限期地重新建立会话连接。</p>
<h4 id="会话连接"><a href="#会话连接" class="headerlink" title="会话连接"></a>会话连接</h4><p>客户端跟服务端进行连接的一个参数是会话过期时间，单位为毫秒，客户端会把请求的会话过期时间发给服务端，服务端会返回一个它可以接受的时间，要求是：<code>tickTime*2 &lt;= session timeout &lt;= tickTime*20</code>。</p>
<p>客户端跟服务端进行连接的另一个参数是默认的观察者，当客户端发生任何状态更改的时候都会通知观察者，在创建一个新连接的情况下，发送给观察者的第一个事件通常是会话连接事件。</p>
<p>当建立一个会话时，服务端会生成一个64位的数字，作为session的标识，并分配给客户端。如果客户端连接到不同的ZooKeeper服务器，它将发送会话id作为连接握手的一部分。作为安全措施，服务端为会话id创建一个密码，任何ZooKeeper服务端都可以验证每当客户端与服务端重新建立会话时，会同时传递session id和密码，服务端验证通过才会建立连接。</p>
<p>如果客户端和服务端集群断开连接后，能在会话超时时间内重新连接上，那么session状态会重新变为<code>CONNECTED</code>，如果在会话超时后重新连接上，那么会话状态将转换到<code>EXPIRED</code>。当会话连接断开的时候，不需要我们自己去重新建立一个新的会话，因为客户端会自动重新连接。只有在明确知道会话状态为<code>EXPIRATION</code>过期状态，我们才需要手动重新创建新的会话。</p>
<p>会话是否过期是由服务端集群管理的，客户端并不能自己管理自己是否过期。当超过会话时间，服务端还没有收到客户端的心跳的话，就会把这个会话标记为过期，然后删除这个会话所创建的所有临时节点，并且通知所有监听了这个节点的会话。在这个时候，客户端和服务端是断开连接的，但它们重连成功，客户端会收到自己被标记为过期这一通知，而在没有重连成功之前，客户端是不会收到过期通知的。</p>
<p>如果会话空闲一段时间，客户端会发送PING请求以保持会话的活动状态。</p>
<h4 id="服务器列表更新"><a href="#服务器列表更新" class="headerlink" title="服务器列表更新"></a>服务器列表更新</h4><p>更新服务器列表，客户端允许使用一个新的连接字符串来更新服务列表，这会使用一个负载均衡算法来重新平衡各个客户端和服务端的连接情况，所以会导致部分客户端断开连接并重新连接到其他服务端。</p>
<h4 id="本地会话"><a href="#本地会话" class="headerlink" title="本地会话"></a>本地会话</h4><p>本地会话，Local Session，在3.5.0版本加入，因为会话的创建和关闭需要耗费较多资源和性能，当ZooKeeper需要处理数千个客户端连接时，它们就是性能的瓶颈，所以在3.5.0版本中加入了本地会话，它们并没有普通（全局）会话的所有功能，可以通过启用<code>localSessionsEnabled</code>来使用本地会话。可以使用<code>localSessionsUpgradingEnabled</code>来限制本地会话升级到全局会话。</p>
<h3 id="监听机制，Watches"><a href="#监听机制，Watches" class="headerlink" title="监听机制，Watches"></a>监听机制，Watches</h3><p>ZooKeeper的所有读操作，<code>getData()</code>，<code>getChildren()</code>，<code>exists()</code>，都可以选择是否设置观察者，ZooKeeper关于监听机制的定义是，监视事件是一次性触发器，当客户端所监视的数据发生更改时，它会收到一个通知。对于监听机制来说，有三个主要特性：</p>
<ul>
<li><strong>一次性触发</strong>，观察事件会在观察的数据更改时被主动发送给客户端，但只会发送一次。</li>
<li><strong>发送给客户端</strong>，除非客户端已经收到了监视事件，否则它绝对不会知道监视的数据已经发生更改，即使网络延时或者一些其他的因素导致不同的客户端收到的事件不一致，但是可以保证不同的客户端收到的事件提醒的顺序都是一致的。</li>
<li><strong>观察者观察的数据</strong>，ZooKeeper服务端会维护两个观察者列表：<strong>数据观察者</strong>和<strong>子节点观察者</strong>。<code>getData()</code>和<code>exists()</code>设置的是数据观察者，<code>getChildren()</code>设置的是子节点观察者。因此，一个成功的<code>setData()</code>会触发数据观察者，一个成功的<code>create()</code>和<code>delete()</code>会触发这个节点的数据观察者和这个节点的父节点的子节点观察者。</li>
</ul>
<h4 id="观察者的语义"><a href="#观察者的语义" class="headerlink" title="观察者的语义"></a>观察者的语义</h4><p>上面提到<code>exists()</code>，<code>getData()</code>，<code>getChildren()</code>都可以设置观察者，下面列出了不同的事件类型以及对应的观察者：</p>
<ul>
<li>Created event，创建类型，通过<code>exists</code>启用</li>
<li>Deleted event，删除类型，通过<code>exists</code>，<code>getData</code>，<code>getChildren</code>启用</li>
<li>Changed event，改变类型，通过<code>exists</code>，<code>getData</code>启用</li>
<li>Child event，子节点类型，通过<code>getChildren</code>启用</li>
</ul>
<h4 id="永久监听，递归监听"><a href="#永久监听，递归监听" class="headerlink" title="永久监听，递归监听"></a>永久监听，递归监听</h4><p>在3.6.0版本加入，客户端可以设置永久的，递归的观察者，这些观察者在被触发的时候不会被删除，并且会递归地监听设置的节点及其子节点。</p>
<h4 id="删除观察者"><a href="#删除观察者" class="headerlink" title="删除观察者"></a>删除观察者</h4><p>服务端可以通过调用<code>removeWatches</code>来删除观察者，客户端也可以将本地标志设置为true来删除本地观察者，即使没有与服务端连接。下面列出了成功移除观察者后将触发的事件：</p>
<ul>
<li>子节点移除事件：通过调用<code>getChildren</code>添加的观察者</li>
<li>数据节点移除事件：通过调用<code>exists</code>或<code>getData</code>添加的观察者</li>
<li>永久节点移除事件：移除永久观察者</li>
</ul>
<h4 id="关于监听机制的保证"><a href="#关于监听机制的保证" class="headerlink" title="关于监听机制的保证"></a>关于监听机制的保证</h4><ul>
<li>监视是根据其他事件、其他监视和异步响应排序的，ZooKeeper客户端保证所有内容都是按顺序发送的</li>
<li>客户端只有接收到所监听的节点的观察事件后，才能看到该节点对应的新数据</li>
<li>ZooKeeper的监视事件顺序与ZooKeeper服务看到的更新顺序相对应</li>
</ul>
<h3 id="使用ACL进行访问控制"><a href="#使用ACL进行访问控制" class="headerlink" title="使用ACL进行访问控制"></a>使用ACL进行访问控制</h3><p>ZooKeeper使用ACL对节点进行访问控制，提供以下权限：</p>
<ul>
<li><strong>CREATE</strong>：可以创建子节点</li>
<li><strong>READ</strong>：可以从节点读取数据并列出其子节点</li>
<li><strong>WRITE</strong>：可以往节点写入数据</li>
<li><strong>DELETE</strong>：可以删除子节点</li>
<li><strong>ADMIN</strong>：可以设置权限</li>
</ul>
<h3 id="一致性保证，Consistency-Guarantees"><a href="#一致性保证，Consistency-Guarantees" class="headerlink" title="一致性保证，Consistency Guarantees"></a>一致性保证，Consistency Guarantees</h3><p>ZooKeeper是一种高性能、可伸缩的服务。读和写操作都设计得很快，虽然读操作会较快些，这是因为在读操作的情况下，ZooKeeper还可以为较旧的数据提供服务，这是由于ZooKeeper的一致性保证：</p>
<ul>
<li>顺序一致性：客户端的更新请求将按发送的顺序应用</li>
<li>原子性：更新成功或失败都是原子的，没有中间结果</li>
<li>单一系统映像：无论连接到哪个服务器，客户端都讲看到相同的服务视图，即使客户端因为故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的旧视图</li>
<li>可靠性：一旦更新完成，它将从那时起一直持续到客户端覆盖更新为止</li>
<li>时效性：客户端对系统的视图保证在一定的时间范围内是最新的（大约几十秒），即客户端能在一个确定的时间内得到最新的数据</li>
</ul>
<br>

<p>参考：</p>
<p><a href="https://zookeeper.apache.org/doc/r3.6.2/zookeeperProgrammers.html" target="_blank" rel="noopener">ZooKeeper官方文档</a></p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序性能优化（四）：Java程序优化</title>
    <url>/2020/09/24/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本篇文章是葛一鸣《Java程序性能优化》读书笔记的第四篇，主要从代码层面对程序进行优化，内容有字符串优化、核心数据结构优化和NIO等。<a id="more"></a></p>
<h3 id="字符串优化">字符串优化</h3>
<p>String底层是char数组，String对象有3个基本特点：</p>
<ul>
<li>不变性：String对象一旦生成则不能再进行改变，当多个线程共享一个String对象并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。</li>
<li>针对常量池的优化：当两个String对象拥有相同的值时，只会引用常量池中的同一个拷贝，这样当一个字符串反复出现时，可以大幅度节省内存空间。</li>
<li>类的final定义：String对象不可能有任何子类，这是对系统安全性的考虑。</li>
</ul>
<h4 id="substring-方法的内存泄漏">subString()方法的内存泄漏</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIdx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIdx, <span class="keyword">int</span> endIdx)</span></span></span><br></pre></td></tr></table></figure>
<p>在substring()方法内会返回一个新建的String对象，它的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String(<span class="keyword">int</span> offset, <span class="keyword">int</span> count, <span class="keyword">char</span> value[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是通过偏移量来决定实际取值，比如有字符串str为&quot;abcdefghijklmn&quot;，通过偏移量和长度返回&quot;ab&quot;，但是截取的字符串实际上仍包含了原生字符串的所有内容，并占据了相应的空间，只是通过偏移量和长度来决定自己的实际取值，这种做法提高了运算速度却也浪费了大量的内存空间，是空间换时间的策略。</p>
<p>substring()可能会导致程序所占用的内存不断扩大，直到溢出，虽然Full GC不停地工作，但每次释放的每次都很微少。这是因为substring()方法调用了String(int offset, int count, char value[])构造函数，它采用了空间换时间的手段。</p>
<h4 id="字符串分割和查找">字符串分割和查找</h4>
<p>三种分割方法性能对比如下：</p>
<p><img src="/2020/09/24/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.PNG" alt="字符串分割性能比较"></p>
<p>charAt()方法具有很高的效率，适合高频率地调用。</p>
<p>String对象进行修改操作的时候总是会生成新的对象，所以其性能相对较差，可使用StringBuffer和StringBuilder类创建经常需要修改的字符串对象。</p>
<p>Java底层对String字符串累加操作进行了优化：</p>
<ul>
<li>对静态字符串的连接操作，会在编译时进行彻底的优化，将多个连接操作的字符串在编译时合成一个单独的长字符串</li>
<li>对于变量字符串的累加，底层使用了StringBuilder对象进行字符串的累加</li>
<li>String的加法操作虽然会被优化，但编译器并不足够聪明，故应少用”+“和”+=“这种操作，其次，String的concat()方法效率远远高于&quot;+“和”+=&quot;运算符，但又远远低于StringBuilder类。</li>
</ul>
<p>StringBuffer对几乎所有方法都做了同步，而StringBuilder没有，故StringBuilder不能保证线程安全。</p>
<h3 id="核心数据结构">核心数据结构</h3>
<p>在java.util包内提供了很多常用的数据结构，如List、Map、Set。</p>
<h4 id="list接口">List接口</h4>
<p><img src="/2020/09/24/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/List%E7%B1%BB%E6%97%8F.PNG" alt="List类族"></p>
<p>ArrayList和Vector底层都是数组，区别是Vector绝大部分方法都做了线程同步，而ArrayList没有。LinkedList使用了循环双向链表的结构。</p>
<p>对于ArrayList这种基于数组的实现，随机访问速度很快，而LinkedList等基于链表的实现，随机访问性能则很差。</p>
<h4 id="map接口">Map接口</h4>
<p><img src="/2020/09/24/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/Map%E7%B1%BB%E6%97%8F.PNG" alt="Map类族"></p>
<p>HashTable的大部分方法都做了同步，而HashMap没有，故HashMap不是线程安全的。</p>
<p>HashMap是将key做hash算法，然后将hash值映射到内存地址，直接取得key所对应的数据，HashMap的取值操作是高效的。</p>
<p>HashMap实际上是一种链表的数组，只要hashCode()和hash()方法实现得足够好，能够尽可能地减少冲突的产生，那么对HashMap的操作几乎等价于对数组的随机访问操作，具有很好的性能。</p>
<p>HashMap和ArrayList、Vector一样，底层是一个数组，故空间不足时需要拓展，较费时间，而设置合理的初始大小和负载因子可以减少扩容的次数。</p>
<p>LinkedHashMap继承自HashMap，高性能的同时也是有序的，有两种类型的顺序：一是元素插入时的顺序，二是最近访问的顺序。可以通过以下构造函数进行定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span></span></span><br></pre></td></tr></table></figure>
<p>其中accessOrder为true时，安装元素最后访问时间排序，为false时，则按照插入顺序，默认为false。</p>
<p>TreeMap虽然性能较HashMap差一些，但能够基于元素的固有顺序进行排序，由Comparable或Comparator确定。TreeMap是根据key进行排序，故为了确定key的排序方式，可以两种方式指定：</p>
<p>一是在构造函数中注入一个Comparator，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span></span></span><br></pre></td></tr></table></figure>
<p>二是使用一个实现了Comparable接口的key。</p>
<p>而且TreeMap的排序是必须实现的。</p>
<h4 id="set接口">Set接口</h4>
<p>Set集合中的元素是不能重复的，HashSet的输出毫无规律，LinkedHashSet的输出顺序和输入顺序完全一致，TreeSet则将所有输出从小到大排序。</p>
<h4 id="randomaccess接口">RandomAccess接口</h4>
<p>RandomAccess接口是一个标志性接口，本身并没有提供任何方法，任何实现该接口的对象都可以认为是支持快速随机访问的对象，该接口的主要目的是标识那些支持快速随机访问的List实现。任何一个基于数组的List都实现了RandomAccess接口，而基于链表的没有。</p>
<p>对于没有实现RandomAccess接口的List而言，其随机访问性能是极低的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序性能优化（三）：常用优化组件和方法</title>
    <url>/2020/09/23/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E7%BB%84%E4%BB%B6%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本篇文章是葛一鸣《Java程序性能优化》读书笔记的第三篇，主要内容有常用的优化组件和方法，以及常用的优化思想。<a id="more"></a></p>
<h3 id="缓冲（Buffer）"><a href="#缓冲（Buffer）" class="headerlink" title="缓冲（Buffer）"></a>缓冲（Buffer）</h3><p>缓冲区是一块特定的内存区域，能够缓解应用程序上下层之间的性能差异，提供系统的性能。缓冲最常用的场景是提供I/O的速度，JDK的很多I/O组件都提供了缓冲功能，如BufferedWriter。</p>
<p>缓冲区不宜过小，过小无法起到缓冲作用，也不宜过大，过大会浪费系统内存，增加GC负担。</p>
<p>由于I/O操作很容易成为性能瓶颈，故尽可能在I/O读写中加入缓冲组件，以提高系统的性能。</p>
<h3 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h3><p>缓存也是一块为了提高系统性能而开辟的内存空间，主要作用是暂存数据处理结果，并提供下次访问使用。缓存可以保存一些来之不易的数据或计算结果，当需要再次使用时，可以从缓冲中低成本地获取，而不需要再占用宝贵的系统资源。</p>
<h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><p>对象池化是一种非常常用的系统优化技术，核心思想是：如果一个类被频繁请求使用，那么不必每次都生成一个实例，可以将这个类的一些实例保存在一个池中，待需要使用的时候直接从池中获取。如线程池和数据库连接池。</p>
<p>对于经常使用，并且创建很费时的大型对象来说，可以使用对象池维护，这样不仅可以节省获得对象实例的成本，还可以减轻GC频繁回收这些对象产生的系统压力。</p>
<h3 id="并行替代串行"><a href="#并行替代串行" class="headerlink" title="并行替代串行"></a>并行替代串行</h3><p>传统的串行程序比较不能发挥CPU的最大潜能，而并行可以将CPU性能发挥到极致。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>如果应用并发数很多，单台计算机就无法承受，为了保证应用的服务质量，需要使用多台机器协同工作，将系统负载尽可能均匀地分配到各个机器上。</p>
<h3 id="时间换空间"><a href="#时间换空间" class="headerlink" title="时间换空间"></a>时间换空间</h3><p>通常用于嵌入式设备，或者内存、硬盘空间不足的情况，通过牺牲CPU来获得原本需要更多内存或者硬盘空间才能完成的工作。</p>
<h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>尝试使用更多的内存或者磁盘空间换取CPU资源或者网络资源，通过增加系统的内存消耗，来加快程序的运行速度。典型应用是缓存，在一些算法中也会选择空间换时间。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序性能优化（二）：设计优化之设计模式</title>
    <url>/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>本篇文章是葛一鸣《Java程序性能优化》读书笔记的第二篇，主要内容有常用的与性能相关的设计模式。<a id="more"></a></p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式是对某一特定问题的成熟的解决方案。</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>确保系统中一个类只产生一个实例。对于频繁使用的对象，可以省略创建对象所花费的时间，另外，由于new操作的次数减少，对内存使用频率会降低，将减轻GC压力，缩短GC停顿时间。</p>
<p>单例类必须要有一个private访问级别的构造函数。可分为饿汉和懒汉两种类型的单例模式。</p>
<p>序列化和反序列化可能会破坏单例。</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>使用代理对象完成用户请求，屏蔽用户对真实对象的访问。使用代理模式可能是出于安全原因，也可能是为了提升系统性能，延迟加载真实对象。</p>
<p>代理模式的主要参与者有4个：</p>
<ul>
<li>主题接口：定义代理类和真实类的公共对外方法。</li>
<li>真实主题：真正实现业务逻辑的类。</li>
<li>代理类：用来代理和封装真实主题。</li>
<li>Main：客户端，使用代理类和主题接口完成一些工作。</li>
</ul>
<p>在系统启动时，将消耗资源最多的方法都使用代理模式分离，就可以加快系统的启动速度，减少用户等待的时间。</p>
<p>延迟加载的核心思想是：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的位置，只要在真正使用的时候才对它进行加载。</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>动态代理是指在运行时动态生成代理类，即代理类的字节码将在运行时生成并载入当前的ClassLoader。与静态代理类相比，动态类不需要为真实主题写一个形式上完全一样的封装类，其次，一些动态代理的生成方法甚至可以在运行时指定代理类的执行逻辑，从而大大提升系统的灵活性。</p>
<p>生成动态代理类的方法有：JDK自带的动态代理，CGLIB，Javassist或者ASM库。</p>
<p>实现动态代理的基本步骤：</p>
<p>根据指定的回调类生成Class字节码—–&gt;通过defineClass()将字节码定义为类—–&gt;使用反射机制生成该类的实例</p>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>享元模式以提高系统性能为目的，核心思想是：如果一个系统中存在多个相同的对象，那么只需共享一份对象的拷贝，而不必为每一次使用都创建新的对象。在享元模式中，常常会有一个工厂类来维护和创建对象。</p>
<p>享元模式对性能提升的主要帮助有两点：</p>
<ul>
<li>可以节省重复创建对象的开销。</li>
<li>由于创建对象的数量减少，所以对系统内存的需求也减小，使得GC的压力也相应地降低，进而使得系统拥有一个更健康的内存结构和更快的反应速度。</li>
</ul>
<p>享元模式的主要角色有：</p>
<ul>
<li>享元工厂：用以创建具体享元类，维护相同的享元对象。</li>
<li>抽象享元：定义需共享的对象的业务接口。</li>
<li>具体享元类：实现抽象享元类的接口，完成某一具体逻辑。</li>
<li>Main：使用享元模式的组件，通过享元工厂取得享元对象。</li>
</ul>
<p>结构如图所示：</p>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.PNG" alt="享元模式类图"></p>
<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p>装饰者模式可以动态添加对象功能，通过委托机制，复用系统中的各个组件，在运行时将功能组件进行叠加，从而构造一个拥有所以这些组件的功能。装饰者模式可以有效分离性能组件和功能组件，从而提升模块的可维护性并增加模块的复用性。</p>
<p>装饰者模式的主要角色有：</p>
<ul>
<li>组件接口：是装饰者和被装饰者的超类或者接口，定义了被装饰者的核心功能和装饰者需要加强的功能点。</li>
<li>具体组件：具体组件实现了组件接口的核心方法，完成具体的业务逻辑，也是被装饰的对象。</li>
<li>装饰者：实现组件接口，并持有一个具体的被装饰者对象。</li>
<li>具体装饰者：具体实现装饰的业务逻辑。</li>
</ul>
<p>JDK中的OutputStream和InputStream类族的实现是装饰者模式的典型应用，通过嵌套的方式不断将对象聚合起来，工作流程如图所示：</p>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.PNG" alt="观察者模式的工作流程"></p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>观察者模式可以用于事件监听、通知发布等场合，可以确保观察者在不使用轮询监控的情况下，及时收到相关消息和事件。</p>
<p>观察者模式的主要角色如下：</p>
<ul>
<li>主题接口：被观察的对象状态发生改变时，会将这个变化通知观察者，它维护了观察者所需要依赖的状态。</li>
<li>具体主题：实现了主题接口中的方法，如新增观察者、删除观察者和通知观察者，其内部维护一个观察者列表。</li>
<li>观察者接口：定义了观察者的基本方法，当依赖状态发生改变时，主题接口会调用观察者的update()方法。</li>
<li>具体观察者，实现了观察者接口的update()方法。</li>
</ul>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.PNG" alt="观察者模式结构"></p>
<h4 id="Value-Object-模式"><a href="#Value-Object-模式" class="headerlink" title="Value Object 模式"></a>Value Object 模式</h4><p>Value Object模式提倡将一个对象的各个属性进行封装，将封装后的对象在网络中传递，从而使系统拥有更好的交互模型，并且减少网络通信数据，从而提高系统性能。对象必须是一个可串行化的对象。</p>
<h4 id="业务代理模式"><a href="#业务代理模式" class="headerlink" title="业务代理模式"></a>业务代理模式</h4><p>业务代理模式将一组由远程方法调用构成的业务流程，封装在一个位于展示层的代理类中，即将一些业务流程封装在前台系统，为系统性能优化提供了基础平台。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 程序性能优化（一）：Java性能调优概述</title>
    <url>/2020/09/14/Java-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>本系列文章为葛一鸣《Java程序性能优化》的学习笔记，本篇为第1章，Java性能调优概述，主要内容有：程序性能指标、调优手段等。<a id="more"></a></p>
<h3 id="程序的性能"><a href="#程序的性能" class="headerlink" title="程序的性能"></a>程序的性能</h3><p>一般情况，程序的性能通过几个方面来表现：</p>
<ul>
<li>执行速度：程序反映是否迅速，相应时间是否够短。</li>
<li>内存分配：内存分配是否合理，是否消耗过多内存或者存在内存泄漏。</li>
<li>启动时间：程序从启动到可以正常处理业务所花费时间。</li>
<li>负载承受能力：当系统压力上升时，系统的执行速度、响应时间的上升曲线是否平缓。</li>
</ul>
<p>为了能够进行性能分析，需要有可以定量评测的性能指标，如下：</p>
<ul>
<li>执行时间：程序开始运行到结束所用时间。</li>
<li>CPU时间：函数或线程所占用的时间。</li>
<li>内存分配：程序运行时所占用的内存空间。</li>
<li>磁盘吞吐量：I/O的使用情况。</li>
<li>网络吞吐量：网络的使用情况。</li>
<li>响应时间：系统对事件做出响应的时间，越短越好。</li>
</ul>
<h3 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h3><p>根据木桶原理，系统的最终性能取决于性能表现最差的组件，故在提升系统整体性能时，必须对系统中表现最差的组件进行优化。</p>
<p>最有可能成为系统性能瓶颈的计算资源如下：</p>
<ul>
<li>磁盘I/O：磁盘I/O读写比内存慢很多，故低效的I/O操作会拖累整个系统。</li>
<li>网络操作：与磁盘I/O类似，网络环境存在不确定性。</li>
<li>CPU：对计算资源要求较高的应用需要大量占用CPU，对CPU的争夺会导致性能问题，如科学计算、3D渲染等应用。</li>
<li>异常：Java应用的异常捕获和处理非常消耗资源。</li>
<li>数据库：读写耗时，同步操作缓慢。</li>
<li>锁竞争：对于高并发程序，锁竞争会明显增加上下文的切换，浪费CPU资源。</li>
<li>内存：高频率的内存交换和扫描，较少见，内存相对于磁盘容量较小。</li>
</ul>
<h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p>Amdahl定律定义了串行系统并行化后加速比的计算公式和理论上限。</p>
<p><strong>加速比 = 优化前系统耗时 / 优化后系统耗时</strong></p>
<p>加速比越高，优化效果越明显。</p>
<p>Amdahl定律给出了加速比与系统并行度和处理器数量的关系，设加速比为<em>Speedup</em>，系统内必须串行化的程序比重为<em>F</em>，CPU处理器数量为<em>N</em>，则有：<br>$$<br>Speedup &lt;= \frac{1}{F + \frac{1 - F}{N}}<br>$$<br>根据该关系可以知道：使用多核CPU对系统进行优化，优化的效果取决于CPU的数量以及系统中的串行化程序的比重。CPU数量越多，串行化比重越低，则优化效果越好。</p>
<h3 id="性能调优的层次"><a href="#性能调优的层次" class="headerlink" title="性能调优的层次"></a>性能调优的层次</h3><p>可以从系统的各个角度和层次对系统进行优化，从而提升系统性能。</p>
<h4 id="设计调优"><a href="#设计调优" class="headerlink" title="设计调优"></a>设计调优</h4><p>设计调优位于所有调优手段的最上层，对系统性能的影响是最大的。设计优化的显著特点是：可以规避某一个组件的性能问题，而非改良该组件的实现。</p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>对程序代码进行优化和改进，是对系统性能产生最直接影响的优化方法。</p>
<h4 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h4><p>JVM调优通常在软件开发后期进行，JVM的各项参数会直接影响到Java程序的性能，比如堆大小、垃圾回收策略等，需要依据程序的特点，设置合理的JVM启动参数。</p>
<h4 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h4><p>在应用层对SQL语句进行优化，对数据库进行优化，对数据库软件进行优化。</p>
<h4 id="操作系统优化"><a href="#操作系统优化" class="headerlink" title="操作系统优化"></a>操作系统优化</h4><p>作为程序运行的基础平台，操作系统的性能对应用系统也有较大影响，不同类型的操作系统的调优手段和参数会有所不同。</p>
<h3 id="基本调优策略和手段"><a href="#基本调优策略和手段" class="headerlink" title="基本调优策略和手段"></a>基本调优策略和手段</h3><p>在对系统进行调优时 ，应该找到导致问题的性能瓶颈，对其进行优化，就能从根本上提升性能。</p>
<p>优化的一般步骤如下：</p>
<p><img src="/2020/09/14/Java-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4.PNG" alt="性能优化的一般步骤"></p>
<p>软件优化需要在软件功能、正确性和可维护性取得平衡，而不应该过分追求软件性能。任何优化都是为了解决具体的软件问题。性能优化必须有明确的目标，不能为了优化而优化。</p>
<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven基础</title>
    <url>/2020/08/30/Maven%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。<a id="more"></a></p>
<h3 id="Maven能做什么"><a href="#Maven能做什么" class="headerlink" title="Maven能做什么"></a>Maven能做什么</h3><p>构建工程，管理jar包，编译代码，自动运行单元测试，打包，生成报表，部署项目，生成Web站点。</p>
<h3 id="Maven优势"><a href="#Maven优势" class="headerlink" title="Maven优势"></a>Maven优势</h3><p>传统web项目，jar包在项目中；</p>
<p>maven开发的项目，jar包不在项目中，而是根据jar包的坐标从jar包仓库中查找。</p>
<p>能够减少项目磁盘空间（特别是多个项目的时候，传统下每个项目都有jar包，maven是共用仓库中的）。</p>
<h3 id="项目的一键构建"><a href="#项目的一键构建" class="headerlink" title="项目的一键构建"></a>项目的一键构建</h3><p>项目从编译、测试、运行、打包、安装、部署整个过程都可以交给maven进行管理，这个过程称为构建。</p>
<p>maven规范化构建流程如下：</p>
<p>清理  —&gt;   编译  —&gt;   测试  —&gt;   报告  —&gt;   打包  —&gt;   部署</p>
<h3 id="仓库种类和彼此关系"><a href="#仓库种类和彼此关系" class="headerlink" title="仓库种类和彼此关系"></a>仓库种类和彼此关系</h3><p>仓库分三类：本地仓库，远程仓库（私服），中央仓库</p>
<p>默认情况下：先找本地，本地没有再去中央</p>
<p>公司使用：先找本地，本地没有找远程，远程可以从本地和中央下jar包</p>
<h3 id="maven标准目录结构"><a href="#maven标准目录结构" class="headerlink" title="maven标准目录结构"></a>maven标准目录结构</h3><p>项目可分为：核心代码部分，配置文件部分，测试代码部分，测试配置文件部分</p>
<p>maven目录结构：</p>
<p>src/main/java  核心代码部分</p>
<p>src/main/resources  配置文件部分</p>
<p>src/test/java  测试代码部分</p>
<p>src/test/resources  测试配置文件部分</p>
<p>src/main/webapp  页面资源，js，css，图片等</p>
<h3 id="maven常用命令"><a href="#maven常用命令" class="headerlink" title="maven常用命令"></a>maven常用命令</h3><p>mvn clean   清除项目编译信息，删除target文件夹</p>
<p>mvn compile   编译正式的代码，创建target文件夹</p>
<p>mvn test   编译正式的代码和测试文件夹下的代码</p>
<p>mvn package   对项目正式、测试的代码进行编译，同时打包并放置于target文件夹</p>
<p>mvn install   相当于mvn package后，将生成的包安装到本地仓库</p>
<h3 id="maven生命周期"><a href="#maven生命周期" class="headerlink" title="maven生命周期"></a>maven生命周期</h3><p>清理生命周期：</p>
<p>clean</p>
<p>默认生命周期：</p>
<p>编译（compile）</p>
<p>测试（test）</p>
<p>打包（package）</p>
<p>安装（install）</p>
<p>发布（deploy）</p>
<p>每一步命令都会包含前面所有的命令</p>
<h3 id="maven概念模型图"><a href="#maven概念模型图" class="headerlink" title="maven概念模型图"></a>maven概念模型图</h3><p><img src="/2020/08/30/Maven%E5%9F%BA%E7%A1%80/maven%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt></p>
<p>项目对象模型（POM）包括：</p>
<p>项目自身信息、项目运行所依赖的jar包信息、项目运行环境信息，比如jdk、tomcat信息</p>
<p>依赖管理模型（Dependency）：</p>
<p>公司组织的名称、项目名、版本号</p>
<p>一键构建：</p>
<p>每一个构造项目的命令都对应了maven底层一个插件</p>
<h3 id="maven依赖范围"><a href="#maven依赖范围" class="headerlink" title="maven依赖范围"></a>maven依赖范围</h3><table>
<thead>
<tr>
<th>依赖范围</th>
<th>对于编译classpath有效</th>
<th>对于测试classpath有效</th>
<th>对于运行classpath有效</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>spring-core</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>JDBC</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>本地仓库之外的类库</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo框架介绍</title>
    <url>/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Dubbo是阿里巴巴公司开源的一款高性能Java RPC框架，提供了三个核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。<a id="more"></a></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.jpg" alt="架构演进"></p>
<h5 id="单一应用结构"><a href="#单一应用结构" class="headerlink" title="单一应用结构"></a>单一应用结构</h5><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<h5 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h5><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h5 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h5><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h5 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h5><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/dubbo-service-governance.jpg" alt="Dubbo服务治理"></p>
<p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p>
<p><strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</strong> 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p>
<p><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。</p>
<p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>
<p>以上是 Dubbo 最基本的几个需求。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/architecture.png" alt="Dubbo架构"></p>
<h5 id="节点说明"><a href="#节点说明" class="headerlink" title="节点说明"></a>节点说明</h5><table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<h5 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h5><p>​    0. 服务容器负责启动，加载，运行服务提供者。</p>
<p>​    1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>​    2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>​    3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>​    4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>​    5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h5 id="本地服务-Spring-配置"><a href="#本地服务-Spring-配置" class="headerlink" title="本地服务 Spring 配置"></a>本地服务 Spring 配置</h5><p>local.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxServiceImpl”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxAction”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxAction”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“xxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="远程服务-Spring-配置"><a href="#远程服务-Spring-配置" class="headerlink" title="远程服务 Spring 配置"></a>远程服务 Spring 配置</h5><p>在本地服务的基础上，只需做简单配置，即可完成远程化：</p>
<ul>
<li>将上面的 <code>local.xml</code> 配置拆分成两份，将服务定义部分放在服务提供方 <code>remote-provider.xml</code>，将服务引用部分放在服务消费方 <code>remote-consumer.xml</code>。</li>
<li>并在提供方增加暴露服务配置 <code>&lt;dubbo:service&gt;</code>，在消费方增加引用服务配置 <code>&lt;dubbo:reference&gt;</code>。</li>
</ul>
<p>remote-provider.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 和本地服务一样实现远程服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxServiceImpl”</span> /&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 增加暴露远程服务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>remote-consumer.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 增加引用远程服务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和本地服务一样使用远程服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxAction”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxAction”</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“xxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p>参考：</p>
<p><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">Dubbo官方文档</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>快速弄懂分布式和微服务的关系</title>
    <url>/2020/08/10/%E5%BF%AB%E9%80%9F%E5%BC%84%E6%87%82%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>分布式和微服务是什么关系？简单来说，分布式和微服务的概念比较相似，微服务是一种特殊的分布式。但是分布式和微服务在架构、作用和粒度上有所区别。因此，两者的关系是既相互联系又相互区别。<a id="more"></a></p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务的意思是将模块拆分成一个个独立的服务单元，通过接口来实现数据的交互。简单来说微服务就是很小的服务，小到一个服务只对应一个<strong>单一的功能</strong>，只做一件事。这个服务可以单独部署运行，服务之间可以通过RPC来进行交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>分布式服务指服务是分散部署在不同的机器上的，一个服务可能负责<strong>几个功能</strong>，是一种面向SOA架构的，服务之间也是通过RPC来交互或者是WebService来交互的。逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署。生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>分布式只是一种手段，把不同的机器分散在不同的地方，然后这些机器间相互协助完成业务。微服务是一种特殊的分布式，换句话说，微服务架构是分布式服务架构的子集。微服务架构通过更细粒度的服务切分，使得整个系统的迭代速度并行程度更高，但是运维的复杂度和性能会随着服务的粒度更细而增加。微服务重在解耦合，使每个模块都独立。分布式重在资源共享与加快计算机计算速度。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>（1）架构不同：微服务的设计是为了不因为某个模块的升级和BUG影响现有的系统业务。微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。</p>
<p>（2）作用不同：分布式是不同模块部署在不同服务器上，分布式主要解决的是网站高并发带来问题。微服务是各服务可独立应用，组合服务也可系统应用。</p>
<p>（3）粒度不同：微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高。</p>
<br>

<p>分布式服务最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常类型</title>
    <url>/2020/07/15/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在Java语言规范中，将派生于Error或者RuntimeException的异常称为Unchecked Exception（非受检异常），所有其他的异常则称为Checked Exception（受检异常）。<a id="more"></a></p>
<h3 id="Checked-Exception"><a href="#Checked-Exception" class="headerlink" title="Checked Exception"></a>Checked Exception</h3><p>Checked Exception是开发者必须在代码中进行恰当处理的Exception，而且<strong>编译器会强制开发者对其进行处理</strong>，我们可以使用<code>catch</code>语句捕获这些异常，或者在方法声明处使用<code>throws</code>抛出该异常。</p>
<p>通常情况下，Checked Exception的发生是超出开发者控制范围的，比如网络连接失败会抛出的<code>IOException</code>，但是我们的程序必须能够预料到这些可能发生的异常，并对其进行处理，保证程序不会在运行过程中崩溃，这也是编译器强制我们对Checked Exception进行处理的原因。假如在文件传输过程中网络中断，我们的程序应该能够捕获到这种异常并进行处理，尝试重新传输文件。</p>
<p>当我们希望方法在被调用时需要明确地处理一些特殊情况时，就应该使用Checked Exception</p>
<h3 id="Unchecked-Exception"><a href="#Unchecked-Exception" class="headerlink" title="Unchecked Exception"></a>Unchecked Exception</h3><p>Unchecked Exception的发生有一部分是因为开发者的代码逻辑错误造成的，比如<code>NullPointerException</code>这种可以通过检查是否为null来避免的异常。</p>
<p>但是也有一部分跟开发者没关系，它们是<code>java.lang.Error</code>的子类，我们不能够预料这部分异常的发生，所以并<strong>不强制</strong>我们对其进行处理，但如果不捕获，在运行期间如果发生异常就会中断程序的执行。比如<code>OutOfMemoryError</code>可能发生在任意一个实例对象创建的时候，但我们不可能在每个实例对象创建的时候都使用<code>catch</code>语句去捕获异常。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面的例子，由于我们没有对Checked Exception进行处理而导致编译失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使上面的代码可以正确编译，我们可以在<code>try/catch</code>块中捕获相应的异常，或者使用<code>throws</code>在main方法声明处抛出异常。</p>
<p>但是如果在main方法内部抛出一个Unchecked Exception，依然可以正确编译，如下面的例子，这是因为Unchecked Exception无法在编译期间被发现，所以即使不处理也能够正常编译。这点在IDE中也可以直接看到效果，如果是能够在编译期间被发现的异常，IDE会有所提示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exception类层次结构"><a href="#Exception类层次结构" class="headerlink" title="Exception类层次结构"></a>Exception类层次结构</h3><p><code>java.lang.Throwable</code>类是一个Checked Exception，它有两个子类：<code>java.lang.Exception</code>和<code>java.lang.Error</code>，Error类是Unchecked Exception，Exception类则是Checked Exception</p>
<p>。</p>
<p>Exception类有一个Unchecked Exception子类：<code>java.lang.RuntimeException</code>，像<code>NullPointerException</code>和<code>ClassCastException</code>都是RuntimeException的子类。RuntimeException和Error的所有子类都是Unchecked Exception，其他的则都是Checked Exception，如下图所示。</p>
<p><img src="/2020/07/15/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/exception-class-hierarchy.png" alt="exception-class-hierarchy"></p>
<p>如果我们自定义一个异常类，那它是Checked Exception还是Unchecked Exception取决于其父类的类型。在对Checked Exception进行catch操作时，需要遵循一定的规则：在catch块中捕获的异常，必须在try块中有出现这种异常的可能性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(java.io.IOException ioe) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子并不能编译成功，这是因为在try块中永远不会抛出IOException。但如果catch块中捕获的是一个Unchecked Exception，那么就不会有这种问题，因为编译器不能检查出Unchecked Exception，那么它倾向于认为catch块中的捕获是能够捕获到的。</p>
<p>Exception和Throwable这两个类比较特殊，虽然它们都是Checked Exception，但是我们依然可以在catch块中捕获它们，即使它们并没有在try块中抛出异常的可能性，比如下面的代码就能够正常编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exception和Throwable之所以比较特殊是因为它们这两个类都有Unchecked Exception类型的子类，所以编译器允许我们捕获它们（编译器认为我们在捕获的是Unchecked Exception）。</p>
<h3 id="JVM和程序异常"><a href="#JVM和程序异常" class="headerlink" title="JVM和程序异常"></a>JVM和程序异常</h3><p>JVM Exception是由JVM自己抛出的异常。例如，我们调用null对象的方法时，JVM会抛出<code>NullPointerException</code>,或者出现10除以0的情况时，JVM会抛出<code>ArithmeticException</code>，这些异常都是由JVM自动抛出的。</p>
<p>除了JVM异常，其他的都是程序异常。我们可以显式使用<code>throw</code>抛出异常，比如<code>NumberFormatException</code>可能被方法<code>Integer.parseInt</code>或<code>Float.parseFloat</code>抛出，都是程序异常，我们可以在Integer类的parseInt方法的实现中找到以下声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM不会主动抛出这种类型的异常（程序异常），这些异常都是在程序中使用<code>throw</code>显式抛出，当然也可以在程序中显式抛出JVM Exception，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"I told you s shouldn't be null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但通常来说，JVM Exception是不会被开发者抛出的，一般由JVM自己主动抛出，所有的JVM Exception都是Unchecked Exception，而程序异常则可能是Checked Exception或Unchecked Exception。</p>
<h3 id="争论"><a href="#争论" class="headerlink" title="争论"></a>争论</h3><p>关于Checked Exception和Unchecked Exception其实争论是比较大的，Checked Exception的本意是在编译时检查是否存在异常处理程序，强制开发者对异常进行处理，从而减少未正确处理的异常数量。但是，也有观点支持Unchecked Exception，认为沿调用栈向上传播的Checked Exception破坏了顶层的方法，因为这些方法必须声明抛出所有它们调用的方法抛出的异常，而且过多的try/catch块并不能提高开发者的工作效率，还影响代码可读性，Unchecked Exception可以将异常处理集中在少数几个类进行处理，减少无用的try/catch代码块。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Checked Exception必须被显式地捕获或者抛出，而Unchecked Exception则可以不必捕获或抛出。两者从功能的角度来看是等价的，并不存在哪个更强大，选择哪个的原因更多还是看个人习惯或者组织规定问题。    </p>
<br>

<p>参考：</p>
<p>1、<a href="http://www.hacktrix.com/checked-and-unchecked-exceptions-in-java" target="_blank" rel="noopener">Checked and Unchecked Exceptions in Java</a></p>
<p>2、<a href="https://blog.csdn.net/kingzone_2008/article/details/8535287" target="_blank" rel="noopener">Java异常：选择Checked Exception还是Unchecked Exception?</a></p>
<p>3、<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-11.html#jls-11.2" target="_blank" rel="noopener">Compile-Time Checking of Exceptions</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
</search>
