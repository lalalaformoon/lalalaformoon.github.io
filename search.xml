<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis：字典</title>
    <url>/2020/10/24/Redis%EF%BC%9A%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<p>字典在Redis中应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。<a id="more"></a></p>
<h3 id="字典的实现">字典的实现</h3>
<p>Redis的字典的底层实现使用哈希表，一个哈希表可以有多个哈希表节点，而每个哈希表节点就保存字典中的一个键值对。</p>
<h4 id="哈希表">哈希表</h4>
<p>哈希表由 <code>dict.h/dictht</code> 结构定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">    &#x2F;&#x2F; 哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    &#x2F;&#x2F; 哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line">    &#x2F;&#x2F; 哈希表大小掩码，用于计算索引值</span><br><span class="line">    &#x2F;&#x2F; 总是等于 size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    &#x2F;&#x2F; 该哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>table</code> 属性是一个数组， 数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针， 每个 <code>dictEntry</code> 结构保存着一个键值对；</p>
</li>
<li>
<p><code>size</code> 属性记录了哈希表的大小， 也即是 <code>table</code> 数组的大小， 而 <code>used</code> 属性则记录了哈希表目前已有节点（键值对）的数量；</p>
</li>
<li>
<p><code>sizemask</code> 属性的值总是等于 <code>size - 1</code> ， 这个属性和哈希值一起决定一个键应该被放到 <code>table</code> 数组的哪个索引上面。</p>
</li>
</ul>
<h4 id="哈希表节点">哈希表节点</h4>
<p>哈希表节点使用 <code>dict.h/dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    &#x2F;&#x2F; 键</span><br><span class="line">    void *key;</span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    &#x2F;&#x2F; 指向下个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>key</code> 属性保存着键值对中的键， 而 <code>v</code> 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 <code>uint64_t</code> 整数， 又或者是一个 <code>int64_t</code> 整数；</p>
</li>
<li>
<p><code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>
</li>
</ul>
<h4 id="字典">字典</h4>
<p>字典由 <code>dict.h/dict</code> 结构表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    &#x2F;&#x2F; 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line">    &#x2F;&#x2F; 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    &#x2F;&#x2F; 哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    &#x2F;&#x2F; rehash 索引</span><br><span class="line">    &#x2F;&#x2F; 当 rehash 不在进行时，值为 -1</span><br><span class="line">    int rehashidx; &#x2F;* rehashing not in progress if rehashidx &#x3D;&#x3D; -1 *&#x2F;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 属性和 <code>privdata</code> 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数；</li>
<li>而 <code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct dictType &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line">    &#x2F;&#x2F; 复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line">    &#x2F;&#x2F; 复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line">    &#x2F;&#x2F; 对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line">    &#x2F;&#x2F; 销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line">    &#x2F;&#x2F; 销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<p>下图展示了一个普通状态下（没有进行 rehash）的字典：</p>
<p><img src="/2020/10/24/Redis%EF%BC%9A%E5%AD%97%E5%85%B8/%E6%99%AE%E9%80%9A%E5%AD%97%E5%85%B8.PNG" alt="普通字典"></p>
<h3 id="哈希算法">哈希算法</h3>
<p>当将一个新的键值对添加到字典里面时， 程序会先根据键值对的键计算出哈希值<code>hash</code>和索引值<code>index</code>， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>计算哈希值会用到字典中设置的哈希函数，Redis不同版本使用的哈希算法并不一样，比如MurmurHash、SipHash，而计算索引值会用到sizemask属性，索引值计算方式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<h3 id="解决键冲突">解决键冲突</h3>
<p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用<strong>链地址法</strong>（separate chaining）来解决键冲突： 每个哈希表节点都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的<strong>表头位置</strong>（复杂度为 O(1)）， 排在其他已有节点的前面。</p>
<h3 id="rehash">rehash</h3>
<p>rehash，也就是重新散列，当哈希表保存的键值对过多或过少时，就会通过执行rehash来对哈希表的大小进行相应的扩展或收缩。</p>
<p>Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的<code>ht[1]</code>哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及<code>ht[0]</code>当前包含的键值对数量 （也即是<code>ht[0].used</code>属性的值）：
<ul>
<li>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 2^n （<code>2</code> 的 <code>n</code> 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n 。</li>
</ul>
</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code> 哈希表的指定位置上。</li>
<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表）， 释放 <code>ht[0]</code> ， 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<h4 id="哈希表的扩展与收缩">哈希表的扩展与收缩</h4>
<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>
</ol>
<p>其中哈希表的负载因子的计算公式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小</span><br><span class="line">load_factor &#x3D; ht[0].used &#x2F; ht[0].size</span><br></pre></td></tr></table></figure>
<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率， 所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p>
<p>另一方面，当哈希表的负载因子小于 <code>0.1</code> 时，程序自动开始对哈希表执行收缩操作。</p>
<h3 id="渐进式rehash">渐进式rehash</h3>
<p>实际上，rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。这是考虑到哈希表保存的键值对数量非常庞大时，一次性完成rehash可能导致服务器在一段时间内停止服务。</p>
<p>渐进式rehash的详细步骤如下：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<h4 id="渐进式rehash执行期间的哈希表操作">渐进式rehash执行期间的哈希表操作</h4>
<p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code> 里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h3 id="个人想法">个人想法</h3>
<p>从前面的SDS、链表到现在的字典，可以看到Redis的数据结构的思想就是尽可能去做封装，比如说链表，即使没有list这一层的封装也能直接使用，但是通过list的封装可以更加方便地使用管理各个链表节点，字典也是一样，通过dict对键值对数组进行管理，如果把dict去掉其实就是Java中Map的结构。</p>
<br>
<p>参考：</p>
<p>1、<a href="http://redisbook.com/" target="_blank" rel="noopener">Redis设计与实现</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>字典</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis：链表</title>
    <url>/2020/10/24/Redis%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表。<a id="more"></a></p>
<h3 id="链表和链表节点的实现">链表和链表节点的实现</h3>
<p>每个链表节点使用一个 <code>adlist.h/listNode</code> 结构来表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">    &#x2F;&#x2F; 前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    &#x2F;&#x2F; 后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    &#x2F;&#x2F; 节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<p>多个 <code>listNode</code> 可以通过 <code>prev</code> 和 <code>next</code> 指针组成双向链表。</p>
<p>虽然仅仅使用多个 <code>listNode</code> 结构就可以组成链表， 但使用 <code>adlist.h/list</code> 来持有链表的话， 操作起来会更方便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">    &#x2F;&#x2F; 表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line">    &#x2F;&#x2F; 表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line">    &#x2F;&#x2F; 链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">    &#x2F;&#x2F; 节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    &#x2F;&#x2F; 节点值释放函数</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line">    &#x2F;&#x2F; 节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure>
<p><code>list</code> 结构为链表提供了表头指针 <code>head</code> 、表尾指针 <code>tail</code> ， 以及链表长度计数器 <code>len</code> ， 而 <code>dup</code> 、 <code>free</code> 和 <code>match</code> 成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li><code>dup</code> 函数用于复制链表节点所保存的值；</li>
<li><code>free</code> 函数用于释放链表节点所保存的值；</li>
<li><code>match</code> 函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p>list和listNode组成的链表如下：</p>
<p><img src="/2020/10/24/Redis%EF%BC%9A%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8.PNG" alt="链表"></p>
<h3 id="特性总结">特性总结</h3>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双向： 链表节点带有 <code>prev</code> 和 <code>next</code> 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 <code>prev</code> 指针和表尾节点的 <code>next</code> 指针都指向 <code>NULL</code> ， 对链表的访问以 <code>NULL</code> 为终点。</li>
<li>带表头指针和表尾指针： 通过 <code>list</code> 结构的 <code>head</code> 指针和 <code>tail</code> 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 <code>list</code> 结构的 <code>len</code> 属性来对 <code>list</code> 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 <code>void*</code> 指针来保存节点值， 并且可以通过 <code>list</code> 结构的 <code>dup</code> 、 <code>free</code> 、 <code>match</code> 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<br>
<p>参考：</p>
<p>1、<a href="http://redisbook.com/" target="_blank" rel="noopener">Redis设计与实现</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis：简单动态字符串</title>
    <url>/2020/10/24/Redis%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>简单动态字符串，Simple Dynamic String，简称SDS，是Redis的默认字符串表示。<a id="more"></a></p>
<h3 id="sds的定义">SDS的定义</h3>
<p>每个sds.h/sdsdhr结构表示一个SDS值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应当注意的是，这里的buf数组是称为<strong>字节</strong>数组，跟C语言用来表示字符串的<strong>字符</strong>数组不同，Redis中的数据是以二进制的形式保存在buf数组中的。</p>
<p>下图是一个SDS的示例：</p>
<p><img src="/2020/10/24/Redis%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/SDS%E7%A4%BA%E4%BE%8B.PNG" alt="SDS示例"></p>
<ul>
<li>free属性的值为5，表示这个SDS为buf数组分配了5字节未使用空间；</li>
<li>len属性的值为5，表示这个SDS保存了一个5字节长的字符串；</li>
<li>buf属性是一个char类型的数组，前5个字节分别保存了’R’、‘e’、‘d’、‘i’、‘s’五个字符，第6个字节保存了空字符’\0’。</li>
</ul>
<p>SDS遵循C字符串以空字符结尾的惯例，并且保存空字符的1字节空间不计算在len属性里面。为空字符分配额外的空间、添加空字符到结尾等操作都是由SDS函数自动完成，所以这个空字符对于SDS的使用者是完全透明的。</p>
<h3 id="sds与c字符串的区别">SDS与C字符串的区别</h3>
<p>C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’，例如下图：</p>
<p><img src="/2020/10/24/Redis%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/C%E5%AD%97%E7%AC%A6%E4%B8%B2.PNG" alt="C字符串"></p>
<p>但是，C字符串这种简单的表示方式并不能满足Redis对字符串在安全性、效率以及功能方面的要求。</p>
<h4 id="常数复杂度获取字符串长度">常数复杂度获取字符串长度</h4>
<p>因为C字符串不记录自身的长度信息， 所以为了获取一个C字符串的长度， 程序必须遍历整个字符串， 这个操作的复杂度为 O(N) 。和C字符串不同， 因为SDS在len属性中记录了SDS本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。</p>
<p>设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，故无需手动修改。</p>
<p>通过使用SDS而不是C字符串， Redis将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。</p>
<h4 id="杜绝缓冲区溢出">杜绝缓冲区溢出</h4>
<p>除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。</p>
<p>例如，<code>&lt;string.h&gt;/strcat</code> 函数可以将 <code>src</code> 字符串中的内容拼接到 <code>dest</code> 字符串的末尾：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为 C 字符串不记录自身的长度， 所以 <code>strcat</code> 假定用户在执行这个函数时， 已经为 <code>dest</code> 分配了足够多的内存， 可以容纳 <code>src</code> 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。</p>
<p>比如内存有两个紧邻的字符串：</p>
<p><img src="/2020/10/24/Redis%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/%E7%B4%A7%E9%82%BB%E5%AD%97%E7%AC%A6%E4%B8%B2.PNG" alt="紧邻字符串"></p>
<p>这时通过执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strcat(s1, &quot; Cluster&quot;);</span><br></pre></td></tr></table></figure>
<p>将 <code>s1</code> 的内容修改为 <code>&quot;Redis Cluster&quot;</code> ，但在执行 <code>strcat</code> 之前为 <code>s1</code> 分配足够的空间， 那么在 <code>strcat</code> 函数执行之后， <code>s1</code> 的数据将溢出到 <code>s2</code> 所在的空间中， 导致 <code>s2</code> 保存的内容被意外地修改，如下图：</p>
<p><img src="/2020/10/24/Redis%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BA%A2%E5%87%BA.PNG" alt="字符串溢出"></p>
<p>而与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。</p>
<h4 id="减少修改字符串时带来的内存重分配次数">减少修改字符串时带来的内存重分配次数</h4>
<p>对于C字符串来说，每次增长或缩短一个C字符串，程序都要对保存这个C字符串的数组进行一次内存重分配操作：</p>
<ul>
<li>如果是增长字符串，比如拼接操作（append），那在执行之前需要先通过内存重分配来扩展底层数组的空间大小，否则可能会产生缓冲区溢出；</li>
<li>如果是缩短字符串，比如截断操作（trim），那在执行之前需要通过内存重分配来释放字符串不再使用的那部分空间，否则会产生内存泄漏。</li>
</ul>
<p>因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作，而Redis作为数据库，数据会被频繁修改，且对速度要求严苛，那频繁发生内存重分配会对性能造成影响。</p>
<p>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，<code>buf</code>数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的<code>free</code>属性记录。</p>
<p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p>
<h5 id="空间预分配">空间预分配</h5>
<p>空间预分配用于优化SDS的字符串增长操作：当对一个 SDS 进行修改， 并且需要进行空间扩展的时候， 程序不仅会为SDS分配修改所必需的空间，还会为SDS分配额外的未使用空间。</p>
<p>分配规则如下：</p>
<ul>
<li>如果对SDS进行修改之后，SDS的长度（也即是 <code>len</code> 属性的值）将小于 <code>1 MB</code> ， 那么程序分配和 <code>len</code> 属性同样大小的未使用空间， 这时 SDS <code>len</code> 属性的值将和 <code>free</code> 属性的值相同。举个例子， 如果进行修改之后， SDS 的 <code>len</code> 将变成 <code>13</code> 字节， 那么程序也会分配 <code>13</code> 字节的未使用空间， SDS 的 <code>buf</code> 数组的实际长度将变成 <code>13 + 13 + 1 = 27</code> 字节（额外的一字节用于保存空字符）。</li>
<li>如果对SDS进行修改之后， SDS 的长度将大于等于 <code>1 MB</code> ， 那么程序会分配 <code>1 MB</code> 的未使用空间。</li>
</ul>
<p>通过空间预分配策略，SDS将连续增长 <code>N</code> 次字符串所需的内存重分配次数从必定 <code>N</code> 次降低为最多 <code>N</code> 次。</p>
<h5 id="惰性空间释放">惰性空间释放</h5>
<p>惰性空间释放用于优化SDS的字符串缩短操作：当需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 <code>free</code> 属性将这些字节的数量记录起来， 并等待将来使用。</p>
<p>例如，有这样一个SDS：</p>
<p><img src="/2020/10/24/Redis%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/%E7%BC%A9%E7%9F%AD%E5%89%8D.PNG" alt="缩短前"></p>
<p>对它执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sdstrim(s, <span class="string">"XY"</span>);   <span class="comment">// 移除 SDS 字符串中的所有 'X' 和 'Y'</span></span><br></pre></td></tr></table></figure>
<p>那么该SDS会变成：</p>
<p><img src="/2020/10/24/Redis%EF%BC%9A%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/%E7%BC%A9%E7%9F%AD%E5%90%8E.PNG" alt="缩短后"></p>
<p>执行 <code>sdstrim</code> 之后的SDS并没有释放多出来的8字节空间， 而是将这8字节空间作为未使用空间保留在了SDS里面， 如果将来要对SDS进行增长操作的话， 这些未使用空间就可能会派上用场。</p>
<p>通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</p>
<p>与此同时，SDS也提供了相应的API,让我们可以在有需要时，真正地释放SDS里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。</p>
<h4 id="二进制安全">二进制安全</h4>
<p>因为C 字符串中的字符必须符合某种编码（比如 ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得 C 字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>
<p>但SDS可以以二进制的方式来处理存放在buf数组的数据，并不会对其中的数据做任何限制、过滤或者假设，数据写入时是怎样的，被读取时就是怎样的。这也是由于SDS的buf属性是<strong>字节</strong>数组的原因，Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。</p>
<p>而且，SDS使用len属性来保存字符串长度，而不需要依据空字符来判断字符串是否结束，故可以保存图片、音频等特殊数据格式。</p>
<h4 id="兼容部分c字符串函数">兼容部分C字符串函数</h4>
<p>SDS遵循C字符串以空字符结尾的惯例，会将保存的数据末尾设置为空字符，且会为buf数组多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数，从而避免不必要的代码重复。</p>
<h4 id="总结">总结</h4>
<p>C字符串和SDS之间的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:left">C 字符串</th>
<th style="text-align:left">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">获取字符串长度的复杂度为 O(N) 。</td>
<td style="text-align:left">获取字符串长度的复杂度为 O(1) 。</td>
</tr>
<tr>
<td style="text-align:left">API 是不安全的，可能会造成缓冲区溢出。</td>
<td style="text-align:left">API 是安全的，不会造成缓冲区溢出。</td>
</tr>
<tr>
<td style="text-align:left">修改字符串长度 <code>N</code> 次必然需要执行 <code>N</code> 次内存重分配。</td>
<td style="text-align:left">修改字符串长度 <code>N</code> 次最多需要执行 <code>N</code> 次内存重分配。</td>
</tr>
<tr>
<td style="text-align:left">只能保存文本数据。</td>
<td style="text-align:left">可以保存文本或者二进制数据。</td>
</tr>
<tr>
<td style="text-align:left">可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数。</td>
<td style="text-align:left">可以使用一部分 <code>&lt;string.h&gt;</code> 库中的函数。</td>
</tr>
</tbody>
</table>
<br>
<p>参考：</p>
<p>1、<a href="http://redisbook.com/" target="_blank" rel="noopener">Redis设计与实现</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 缓冲区和通道</title>
    <url>/2020/10/08/Java-NIO-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<p>Java NIO是在Java1.4版本中引入的，可以替代标准的Java IO API，NIO与原来的IO有同样的作用和目的，但是使用方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO能以更加高效的方式进行文件的读写操作。<a id="more"></a></p>
<h3 id="nio与io的主要区别">NIO与IO的主要区别</h3>
<ul>
<li>
<p>传统IO面向流（Stream），NIO面向缓冲区（Buffer）</p>
<p>传统IO是单向的，NIO是双向的</p>
</li>
<li>
<p>传统IO阻塞IO，NIO非阻塞IO</p>
</li>
<li>
<p>NIO有选择器（Selectors）</p>
</li>
</ul>
<h3 id="缓冲区-buffer-和通道-channel">缓冲区（Buffer）和通道（Channel）</h3>
<p>NIO的核心在于通道和缓冲区，通道表示打开到IO设备（如文件、套接字）的连接，若需要使用NIO则需要先获取用于连接IO设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理。<strong>通道负责传输，缓冲区负责存储。</strong></p>
<h4 id="缓冲区">缓冲区</h4>
<p>在Java NIO中负责数据的存储，可以存储不同数据类型的数据，根据数据类型不同（boolean除外），提供了相应类型的缓冲区：<code>ByteBuffer</code>、<code>CharBuffer</code>、<code>ShortBuffer</code>、<code>IntBuffer</code>、<code>LongBuffer</code>、<code>FloatBuffer</code>、<code>DoubleBuffer</code>。上述缓冲区的管理方式几乎一致，通过 <code>allocate()</code> 获取缓冲区，并且它们都是抽象类，且都继承自抽象类<code>Buffer</code>。</p>
<h5 id="buffer的四个核心参数"><code>Buffer</code>的四个核心参数</h5>
<ul>
<li>capacity：容量，表示缓冲区最大存储数据的容量，一旦声明不能改变</li>
<li>limit：界限，表示缓冲区中可以操作数据的大小（limit后的数据不能进行读写）</li>
<li>position：位置，表示缓冲区中正在操作数据的位置，初始化为0</li>
<li>mark：标记，表示记录当前position的位置，可以通过<code>reset()</code>恢复到mark位置，初始化为-1</li>
</ul>
<p>它们的关系是：<em><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></em></p>
<h5 id="常用api示例">常用API示例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配缓冲区大小</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    System.out.println(byteBuffer.position());  <span class="comment">//0</span></span><br><span class="line">    System.out.println(byteBuffer.limit());     <span class="comment">//1024</span></span><br><span class="line">    System.out.println(byteBuffer.capacity());  <span class="comment">//1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//put()存入数据到缓冲区</span></span><br><span class="line">    String str = <span class="string">"abcde"</span>;</span><br><span class="line">    byteBuffer.put(str.getBytes());</span><br><span class="line">    System.out.println(byteBuffer.position());  <span class="comment">//5</span></span><br><span class="line">    System.out.println(byteBuffer.limit());     <span class="comment">//1024</span></span><br><span class="line">    System.out.println(byteBuffer.capacity());  <span class="comment">//1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//flip()切换读取数据模式</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    System.out.println(byteBuffer.position());  <span class="comment">//0</span></span><br><span class="line">    System.out.println(byteBuffer.limit());     <span class="comment">//5</span></span><br><span class="line">    System.out.println(byteBuffer.capacity());  <span class="comment">//1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//get()读取缓冲区中的数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];</span><br><span class="line">    byteBuffer.get(dst);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));     <span class="comment">//abcde</span></span><br><span class="line">    System.out.println(byteBuffer.position());  <span class="comment">//5</span></span><br><span class="line">    System.out.println(byteBuffer.limit());     <span class="comment">//5</span></span><br><span class="line">    System.out.println(byteBuffer.capacity());  <span class="comment">//1024</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mark()标记当前position位置</span></span><br><span class="line">    byteBuffer.mark();</span><br><span class="line">    <span class="comment">//reset()将position恢复到mark位置</span></span><br><span class="line">    byteBuffer.reset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rewind()可重复读</span></span><br><span class="line">    byteBuffer.rewind();</span><br><span class="line">    System.out.println(byteBuffer.position());  <span class="comment">//0</span></span><br><span class="line">    System.out.println(byteBuffer.limit());     <span class="comment">//5</span></span><br><span class="line">    System.out.println(byteBuffer.capacity());  <span class="comment">//1024</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//clear()清空缓冲区，但是缓冲区中的数据实际上依然存在</span></span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    System.out.println(byteBuffer.position());  <span class="comment">//0</span></span><br><span class="line">    System.out.println(byteBuffer.limit());     <span class="comment">//1024</span></span><br><span class="line">    System.out.println(byteBuffer.capacity());  <span class="comment">//1024</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断缓冲区中是否还有剩余数据</span></span><br><span class="line">    <span class="keyword">if</span>(byteBuffer.hasRemaining()) &#123;</span><br><span class="line">        <span class="comment">//获取缓冲区中可以操作的数量</span></span><br><span class="line">        System.out.println(byteBuffer.remaining());     <span class="comment">//1024</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="直接缓冲区与非直接缓冲区">直接缓冲区与非直接缓冲区</h5>
<p>非直接缓冲区：通过<code>allocate()</code>方法分配缓冲区，将缓冲区建立在JVM的内存中</p>
<p>直接缓冲区：通过<code>allocateDirect()</code>方法分配直接缓冲区，将缓冲区建立在物理内存中，可以提高效率</p>
<p>虚拟机会尽量避免将<strong>直接缓冲区</strong>的内容复制到中间缓冲区，也就是尽最大努力直接在此缓冲区上执行本机I/O操作。直接缓冲区可以通过<code>allocateDirect()</code>工厂方法来创建，直接缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。因为直接缓冲区的内容可以<strong>驻留在常规的垃圾回收堆之外</strong>，所以它们对内存的需求较少，建议将直接缓冲区主要分配给易受基础系统的本机I/O操作影响的大型、持久的缓冲区。</p>
<p>可以通过<code>isDirect()</code>来确定是直接缓冲区还是非直接缓冲区，提供该方法的目的是为了能够在性能关键处代码中执行显式缓冲区管理。</p>
<p>非直接缓冲区，应用程序和物理磁盘之间的读写操作需要通过用户地址空间和内核地址空间之间的复制。</p>
<p>直接缓冲区，通过物理内存映射文件。因为少了一次复制的操作，所以直接缓冲区效率比非直接缓冲区高。</p>
<h4 id="通道">通道</h4>
<p>通道（Channel）本身不能直接访问数据，只能与缓冲区（Buffer）进行交互。</p>
<p>java.nio.channels.Channel 接口</p>
<p>|-- FileChannel</p>
<p>|-- SocketChannel</p>
<p>|-- ServerSocketChannel</p>
<p>|-- DatagramChannel</p>
<h5 id="获取通道">获取通道</h5>
<ul>
<li>
<p>Java针对支持通道的类提供了<code>getChannel()</code>方法</p>
<p>本地IO：FileInputStream / FileOutputStream</p>
<p>​				 RandomAccessFile</p>
<p>网络IO：Socket</p>
<p>​				 ServerSocket</p>
<p>​				 DatagramSocket</p>
</li>
<li>
<p>在JDK1.7的NIO2针对各个通道提供了静态方法<code>open()</code></p>
</li>
<li>
<p>在JDK1.7的NIO2的Files工具类的<code>newByteChannel()</code></p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非直接缓冲区，利用通道</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"1.jpg"</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel inChannel = fis.getChannel();</span><br><span class="line">    FileChannel outChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        outChannel.write(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    outChannel.close();</span><br><span class="line">    inChannel.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 直接缓冲区，利用内存映射文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"1.jpg"</span>), StandardOpenOption.READ);</span><br><span class="line">    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"2.jpg"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW);</span><br><span class="line"></span><br><span class="line">    MappedByteBuffer inMappedBuffer = inChannel.map(MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">    MappedByteBuffer outMappedBuffer = outChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[inMappedBuffer.limit()];</span><br><span class="line">    inMappedBuffer.get(dst);</span><br><span class="line">    outMappedBuffer.put(dst);</span><br><span class="line"></span><br><span class="line">    outChannel.close();</span><br><span class="line">    inChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通道之间的数据传输">通道之间的数据传输</h5>
<p><code>transferFrom()</code>和<code>transferTo()</code>，这两个方法也是用直接缓冲区的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接缓冲区</span></span><br><span class="line">inChannel.transferTo(<span class="number">0</span>, inChannel.size(), outChannel);</span><br></pre></td></tr></table></figure>
<h5 id="分散-scatter-与聚集-gather">分散（Scatter）与聚集（Gather）</h5>
<p>分散读取：将通道中的数据分散到多个缓冲区中</p>
<p>聚集写入：将多个缓冲区中的数据聚集到通道中</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper相关概念</title>
    <url>/2020/09/30/ZooKeeper%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>ZooKeeper是一个分布式、开源的分布式应用程序协调服务，它公开了一组简单的原语，分布式应用程序可以基于这些原语来实现更高级别的同步、配置维护、组和命名服务。ZooKeeper目的是减轻分布式应用程序从零开始实现协调服务的任务。本文基于3.6.2版本。<a id="more"></a></p>
<h3 id="数据模型-data-model">数据模型，Data Model</h3>
<p>ZooKeeper有个分层命名空间，就像是一棵树，每个节点能够关联数据，节点的路径都是绝对路径，不允许使用相对路径。关于路径命名还有一些要求：</p>
<ul>
<li>“zookeeper”是保留字，不允许使用</li>
<li>“.” 和 “…” 可以作为命名的一部分，但不允许单独使用，如&quot;a/./b&quot;是不被允许的</li>
</ul>
<h4 id="znodes">ZNodes</h4>
<p>ZooKeeper中的节点被称为znode，znode会维护一个stat结构，其中包括数据更改与ACL更改的版本号，时间戳，有了版本号和时间戳，ZooKeeper能够去验证缓存和协调更新。版本号会随着znode数据的更改而增长，当客户端获取数据时也会获取到数据的版本号，当客户端对数据进行更新或删除操作时，ZooKeeper会对版本号进行比对验证，若不匹配则操作失败。</p>
<p>Znode是程序员访问的主要实体，它们有几个值得一提的特点：</p>
<ul>
<li>监听机制，客户端可以对znode进行监听，当znode发生改变时会触发监听器并且清除监听器，监听器一旦被触发，客户端会收到一个通知。</li>
<li>每个znode上的数据读写都是具有原子性的，每个节点都会有一个ACL（访问控制列表）来限制谁可以做什么。</li>
<li>ZooKeeper并不适合存储大量数据，它被设计来管理协调性数据，这些数据可以是配置、状态信息等，它们相对较小，以千字节为单位，如果非得在ZooKeeper中大容量存储数据，可以将数据存储在其他大容量存储系统中，并在ZooKeeper中存储指向数据存储位置的指针。ZooKeeper一开始的设计目的就不是为了存储大容量数据，而是为了协调数据，还会对节点的数据进行管理，使每个节点的数据不会超过1M。</li>
<li>临时节点，Ephemeral Nodes，只要创建临时节点的会话还存在，临时节点就会存在，当会话结束时，临时节点则会被删除，所以<strong>临时节点不允许有子节点</strong>。会话的临时节点列表可以通过<code>getEphemerals()</code>进行获取。</li>
<li>唯一命名，当创建节点时，ZooKeeper可以在节点路径的最后加上一个单调递增的计数器，该计数器对该节点的父节点来说是唯一的，计数器的格式为10位数字，填充0，例如“0000000001”，计数器为4字节有符号整数，当超过2147483647时会溢出。</li>
<li>容器节点，Container Nodes，在3.6.0版本加入，当容器节点的最后一个子节点被删除，那么该容器节点在未来的某个时刻将被服务端删除。考虑到这个属性，当创建容器节点的子节点时可能会出现<code>KeeperException.NoNodeException</code>异常，此时应该重新创建父容器节点。</li>
<li>TTL节点，在3.6.0版本加入，可以为节点设置一个以毫秒为单位的TTL，当在TTL时间内节点没有被更改，那么该节点在未来的某个时刻将被删除。TTL节点默认是禁用状态，需要在系统属性中启用。</li>
</ul>
<h4 id="zookeeper中的时间">ZooKeeper中的时间</h4>
<ul>
<li><strong>Zxid</strong>，ZooKeeper使用的时间戳，ZooKeeper状态的每次改变都会收到一个zxid形式的时间戳，每次更改都会有唯一的zxid，当zxid1小于zxid2时，说明zxid1在zxid2前发生。</li>
<li><strong>版本号</strong>，每个节点都会有自己的版本号，节点发生变化时版本号会递增，有三个版本号：version（znode数据的更改次数）、cversion（znode子节点的更改次数）、aversion（znode的ACL更改次数）。</li>
<li><strong>心跳时间</strong>，当使用多服务器ZooKeeper时，服务器使用心跳来定义事件的时间，例如状态上传、会话超时、连接超时等，心跳时间间接公开了最小会话时间，最小会话时间是两倍心跳时间，如果客户端请求会话的时间小于最小会话时间，那么服务端会告诉客户端请求会话的时间就是最小会话时间。</li>
<li><strong>真实时间</strong>，ZooKeeper不会使用真实时间，除了在创建或修改节点时需要在stat结构中放入时间戳。</li>
</ul>
<h4 id="stat-结构">Stat 结构</h4>
<p>每个节点都会有stat结构，它包含：</p>
<ul>
<li><strong>czxid</strong>，该节点被创建时所生成的zxid</li>
<li><strong>mzxid</strong>，该节点上一次被修改时所生成的zxid</li>
<li><strong>pzxid</strong>，该节点上一次被修改的子节点所生成的zxid</li>
<li><strong>ctime</strong>，该节点被创建时的时间戳，以毫秒为单位</li>
<li><strong>mtime</strong>，该节点上一次被修改时的时间戳，以毫秒为单位</li>
<li><strong>version</strong>，该节点的数据的更改次数</li>
<li><strong>cversion</strong>，该节点的子节点的更改次数</li>
<li><strong>aversion</strong>，该节点的ACL更改次数</li>
<li><strong>ephemeralOwner</strong>，该临时节点所属的session id，若不是临时节点，则为0</li>
<li><strong>dataLength</strong>，该节点数据字段的长度</li>
<li><strong>numChildren</strong>，该节点的子节点数量</li>
</ul>
<h3 id="会话-sessions">会话，Sessions</h3>
<p>客户端和服务端通过创建句柄的方式来进行连接，就是会话，会话一旦建立成功，状态就是<code>CONNECTING</code>（连接中），然后客户端就会尝试去连接服务端，连接成功后状态会变为<code>CONNECTED</code>（已连接），正常情况下只会有这两种状态。如果发生不可恢复的错误，例如会话过期、身份验证失败或者客户端关闭连接，那么session状态会变为<code>CLOSE</code>（关闭）。下图是会话状态的转换过程。</p>
<p><img src="/2020/09/30/ZooKeeper%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg" alt="会话状态转换"></p>
<p>为了创建一个会话，代码中必须提供一个逗号<code>,</code>分隔的字符串，例如：<code>127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002</code>，包含<code>host:port</code>，客户端会任意选择一个服务端进行连接，如果连接失败或者因为某些原因连接断开，那么客户端会重新连接下一个服务端，直到连接成功。</p>
<h4 id="3-2-0版本新增特性">3.2.0版本新增特性</h4>
<p>3.2.0版本新增特性：可以选择在连接字符串增加一个<code>chroot</code>后缀，例如：<code>127.0.0.1:4545/app/a</code>，在这种情况下，我们访问的<code>/foo/bar</code>其实是ZooKeeper服务端的<code>/app/a/foo/bar</code>节点。</p>
<p>3.2.0版本新增特性：<code>SessionMovedException</code>异常，这是一个内部异常，一般不会被应有程序接触到，发生此异常是因为在另一个服务端上重新建立会话连接的时候收到了请求。例如，一个客户端向服务端A发送请求，但因为网络延迟，所以该客户端超时并连接到新的服务端B，当延迟的数据包到达服务端A时，服务端A会检测到会话已移动，并关闭客户端连接，客户端通常不会看到此错误，因为它们不从那些旧连接中读取数据。还有个比较特殊的情况，当两个客户端尝试使用保存的会话id和密码重新建立同一个服务端时，会出现客户端A重新建立连接，客户端B断开连接，紧接着客户端B就会重连，导致客户端A断开连接，这样会导致这两个客户端尝试无限期地重新建立会话连接。</p>
<h4 id="会话连接">会话连接</h4>
<p>客户端跟服务端进行连接的一个参数是会话过期时间，单位为毫秒，客户端会把请求的会话过期时间发给服务端，服务端会返回一个它可以接受的时间，要求是：<code>tickTime*2 &lt;= session timeout &lt;= tickTime*20</code>。</p>
<p>客户端跟服务端进行连接的另一个参数是默认的观察者，当客户端发生任何状态更改的时候都会通知观察者，在创建一个新连接的情况下，发送给观察者的第一个事件通常是会话连接事件。</p>
<p>当建立一个会话时，服务端会生成一个64位的数字，作为session的标识，并分配给客户端。如果客户端连接到不同的ZooKeeper服务器，它将发送会话id作为连接握手的一部分。作为安全措施，服务端为会话id创建一个密码，任何ZooKeeper服务端都可以验证每当客户端与服务端重新建立会话时，会同时传递session id和密码，服务端验证通过才会建立连接。</p>
<p>如果客户端和服务端集群断开连接后，能在会话超时时间内重新连接上，那么session状态会重新变为<code>CONNECTED</code>，如果在会话超时后重新连接上，那么会话状态将转换到<code>EXPIRED</code>。当会话连接断开的时候，不需要我们自己去重新建立一个新的会话，因为客户端会自动重新连接。只有在明确知道会话状态为<code>EXPIRATION</code>过期状态，我们才需要手动重新创建新的会话。</p>
<p>会话是否过期是由服务端集群管理的，客户端并不能自己管理自己是否过期。当超过会话时间，服务端还没有收到客户端的心跳的话，就会把这个会话标记为过期，然后删除这个会话所创建的所有临时节点，并且通知所有监听了这个节点的会话。在这个时候，客户端和服务端是断开连接的，但它们重连成功，客户端会收到自己被标记为过期这一通知，而在没有重连成功之前，客户端是不会收到过期通知的。</p>
<p>如果会话空闲一段时间，客户端会发送PING请求以保持会话的活动状态。</p>
<h4 id="服务器列表更新">服务器列表更新</h4>
<p>更新服务器列表，客户端允许使用一个新的连接字符串来更新服务列表，这会使用一个负载均衡算法来重新平衡各个客户端和服务端的连接情况，所以会导致部分客户端断开连接并重新连接到其他服务端。</p>
<h4 id="本地会话">本地会话</h4>
<p>本地会话，Local Session，在3.5.0版本加入，因为会话的创建和关闭需要耗费较多资源和性能，当ZooKeeper需要处理数千个客户端连接时，它们就是性能的瓶颈，所以在3.5.0版本中加入了本地会话，它们并没有普通（全局）会话的所有功能，可以通过启用<code>localSessionsEnabled</code>来使用本地会话。可以使用<code>localSessionsUpgradingEnabled</code>来限制本地会话升级到全局会话。</p>
<h3 id="监听机制-watches">监听机制，Watches</h3>
<p>ZooKeeper的所有读操作，<code>getData()</code>，<code>getChildren()</code>，<code>exists()</code>，都可以选择是否设置观察者，ZooKeeper关于监听机制的定义是，监视事件是一次性触发器，当客户端所监视的数据发生更改时，它会收到一个通知。对于监听机制来说，有三个主要特性：</p>
<ul>
<li><strong>一次性触发</strong>，观察事件会在观察的数据更改时被主动发送给客户端，但只会发送一次。</li>
<li><strong>发送给客户端</strong>，除非客户端已经收到了监视事件，否则它绝对不会知道监视的数据已经发生更改，即使网络延时或者一些其他的因素导致不同的客户端收到的事件不一致，但是可以保证不同的客户端收到的事件提醒的顺序都是一致的。</li>
<li><strong>观察者观察的数据</strong>，ZooKeeper服务端会维护两个观察者列表：<strong>数据观察者</strong>和<strong>子节点观察者</strong>。<code>getData()</code>和<code>exists()</code>设置的是数据观察者，<code>getChildren()</code>设置的是子节点观察者。因此，一个成功的<code>setData()</code>会触发数据观察者，一个成功的<code>create()</code>和<code>delete()</code>会触发这个节点的数据观察者和这个节点的父节点的子节点观察者。</li>
</ul>
<h4 id="观察者的语义">观察者的语义</h4>
<p>上面提到<code>exists()</code>，<code>getData()</code>，<code>getChildren()</code>都可以设置观察者，下面列出了不同的事件类型以及对应的观察者：</p>
<ul>
<li>Created event，创建类型，通过<code>exists</code>启用</li>
<li>Deleted event，删除类型，通过<code>exists</code>，<code>getData</code>，<code>getChildren</code>启用</li>
<li>Changed event，改变类型，通过<code>exists</code>，<code>getData</code>启用</li>
<li>Child event，子节点类型，通过<code>getChildren</code>启用</li>
</ul>
<h4 id="永久监听-递归监听">永久监听，递归监听</h4>
<p>在3.6.0版本加入，客户端可以设置永久的，递归的观察者，这些观察者在被触发的时候不会被删除，并且会递归地监听设置的节点及其子节点。</p>
<h4 id="删除观察者">删除观察者</h4>
<p>服务端可以通过调用<code>removeWatches</code>来删除观察者，客户端也可以将本地标志设置为true来删除本地观察者，即使没有与服务端连接。下面列出了成功移除观察者后将触发的事件：</p>
<ul>
<li>子节点移除事件：通过调用<code>getChildren</code>添加的观察者</li>
<li>数据节点移除事件：通过调用<code>exists</code>或<code>getData</code>添加的观察者</li>
<li>永久节点移除事件：移除永久观察者</li>
</ul>
<h4 id="关于监听机制的保证">关于监听机制的保证</h4>
<ul>
<li>监视是根据其他事件、其他监视和异步响应排序的，ZooKeeper客户端保证所有内容都是按顺序发送的</li>
<li>客户端只有接收到所监听的节点的观察事件后，才能看到该节点对应的新数据</li>
<li>ZooKeeper的监视事件顺序与ZooKeeper服务看到的更新顺序相对应</li>
</ul>
<h3 id="使用acl进行访问控制">使用ACL进行访问控制</h3>
<p>ZooKeeper使用ACL对节点进行访问控制，提供以下权限：</p>
<ul>
<li><strong>CREATE</strong>：可以创建子节点</li>
<li><strong>READ</strong>：可以从节点读取数据并列出其子节点</li>
<li><strong>WRITE</strong>：可以往节点写入数据</li>
<li><strong>DELETE</strong>：可以删除子节点</li>
<li><strong>ADMIN</strong>：可以设置权限</li>
</ul>
<h3 id="一致性保证-consistency-guarantees">一致性保证，Consistency Guarantees</h3>
<p>ZooKeeper是一种高性能、可伸缩的服务。读和写操作都设计得很快，虽然读操作会较快些，这是因为在读操作的情况下，ZooKeeper还可以为较旧的数据提供服务，这是由于ZooKeeper的一致性保证：</p>
<ul>
<li>顺序一致性：客户端的更新请求将按发送的顺序应用</li>
<li>原子性：更新成功或失败都是原子的，没有中间结果</li>
<li>单一系统映像：无论连接到哪个服务器，客户端都讲看到相同的服务视图，即使客户端因为故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的旧视图</li>
<li>可靠性：一旦更新完成，它将从那时起一直持续到客户端覆盖更新为止</li>
<li>时效性：客户端对系统的视图保证在一定的时间范围内是最新的（大约几十秒），即客户端能在一个确定的时间内得到最新的数据</li>
</ul>
<br>
<p>参考：</p>
<p><a href="https://zookeeper.apache.org/doc/r3.6.2/zookeeperProgrammers.html" target="_blank" rel="noopener">ZooKeeper官方文档</a></p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序性能优化（四）：Java程序优化</title>
    <url>/2020/09/24/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>本篇文章是葛一鸣《Java程序性能优化》读书笔记的第四篇，主要从代码层面对程序进行优化，内容有字符串优化、核心数据结构优化和NIO等。<a id="more"></a></p>
<h3 id="字符串优化">字符串优化</h3>
<p>String底层是char数组，String对象有3个基本特点：</p>
<ul>
<li>不变性：String对象一旦生成则不能再进行改变，当多个线程共享一个String对象并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。</li>
<li>针对常量池的优化：当两个String对象拥有相同的值时，只会引用常量池中的同一个拷贝，这样当一个字符串反复出现时，可以大幅度节省内存空间。</li>
<li>类的final定义：String对象不可能有任何子类，这是对系统安全性的考虑。</li>
</ul>
<h4 id="substring-方法的内存泄漏">subString()方法的内存泄漏</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIdx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIdx, <span class="keyword">int</span> endIdx)</span></span></span><br></pre></td></tr></table></figure>
<p>在substring()方法内会返回一个新建的String对象，它的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String(<span class="keyword">int</span> offset, <span class="keyword">int</span> count, <span class="keyword">char</span> value[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是通过偏移量来决定实际取值，比如有字符串str为&quot;abcdefghijklmn&quot;，通过偏移量和长度返回&quot;ab&quot;，但是截取的字符串实际上仍包含了原生字符串的所有内容，并占据了相应的空间，只是通过偏移量和长度来决定自己的实际取值，这种做法提高了运算速度却也浪费了大量的内存空间，是空间换时间的策略。</p>
<p>substring()可能会导致程序所占用的内存不断扩大，直到溢出，虽然Full GC不停地工作，但每次释放的每次都很微少。这是因为substring()方法调用了String(int offset, int count, char value[])构造函数，它采用了空间换时间的手段。</p>
<h4 id="字符串分割和查找">字符串分割和查找</h4>
<p>三种分割方法性能对比如下：</p>
<p><img src="/2020/09/24/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.PNG" alt="字符串分割性能比较"></p>
<p>charAt()方法具有很高的效率，适合高频率地调用。</p>
<p>String对象进行修改操作的时候总是会生成新的对象，所以其性能相对较差，可使用StringBuffer和StringBuilder类创建经常需要修改的字符串对象。</p>
<p>Java底层对String字符串累加操作进行了优化：</p>
<ul>
<li>对静态字符串的连接操作，会在编译时进行彻底的优化，将多个连接操作的字符串在编译时合成一个单独的长字符串</li>
<li>对于变量字符串的累加，底层使用了StringBuilder对象进行字符串的累加</li>
<li>String的加法操作虽然会被优化，但编译器并不足够聪明，故应少用”+“和”+=“这种操作，其次，String的concat()方法效率远远高于&quot;+“和”+=&quot;运算符，但又远远低于StringBuilder类。</li>
</ul>
<p>StringBuffer对几乎所有方法都做了同步，而StringBuilder没有，故StringBuilder不能保证线程安全。</p>
<h3 id="核心数据结构">核心数据结构</h3>
<p>在java.util包内提供了很多常用的数据结构，如List、Map、Set。</p>
<h4 id="list接口">List接口</h4>
<p><img src="/2020/09/24/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/List%E7%B1%BB%E6%97%8F.PNG" alt="List类族"></p>
<p>ArrayList和Vector底层都是数组，区别是Vector绝大部分方法都做了线程同步，而ArrayList没有。LinkedList使用了循环双向链表的结构。</p>
<p>对于ArrayList这种基于数组的实现，随机访问速度很快，而LinkedList等基于链表的实现，随机访问性能则很差。</p>
<h4 id="map接口">Map接口</h4>
<p><img src="/2020/09/24/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96/Map%E7%B1%BB%E6%97%8F.PNG" alt="Map类族"></p>
<p>HashTable的大部分方法都做了同步，而HashMap没有，故HashMap不是线程安全的。</p>
<p>HashMap是将key做hash算法，然后将hash值映射到内存地址，直接取得key所对应的数据，HashMap的取值操作是高效的。</p>
<p>HashMap实际上是一种链表的数组，只要hashCode()和hash()方法实现得足够好，能够尽可能地减少冲突的产生，那么对HashMap的操作几乎等价于对数组的随机访问操作，具有很好的性能。</p>
<p>HashMap和ArrayList、Vector一样，底层是一个数组，故空间不足时需要拓展，较费时间，而设置合理的初始大小和负载因子可以减少扩容的次数。</p>
<p>LinkedHashMap继承自HashMap，高性能的同时也是有序的，有两种类型的顺序：一是元素插入时的顺序，二是最近访问的顺序。可以通过以下构造函数进行定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span></span></span><br></pre></td></tr></table></figure>
<p>其中accessOrder为true时，安装元素最后访问时间排序，为false时，则按照插入顺序，默认为false。</p>
<p>TreeMap虽然性能较HashMap差一些，但能够基于元素的固有顺序进行排序，由Comparable或Comparator确定。TreeMap是根据key进行排序，故为了确定key的排序方式，可以两种方式指定：</p>
<p>一是在构造函数中注入一个Comparator，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span></span></span><br></pre></td></tr></table></figure>
<p>二是使用一个实现了Comparable接口的key。</p>
<p>而且TreeMap的排序是必须实现的。</p>
<h4 id="set接口">Set接口</h4>
<p>Set集合中的元素是不能重复的，HashSet的输出毫无规律，LinkedHashSet的输出顺序和输入顺序完全一致，TreeSet则将所有输出从小到大排序。</p>
<h4 id="randomaccess接口">RandomAccess接口</h4>
<p>RandomAccess接口是一个标志性接口，本身并没有提供任何方法，任何实现该接口的对象都可以认为是支持快速随机访问的对象，该接口的主要目的是标识那些支持快速随机访问的List实现。任何一个基于数组的List都实现了RandomAccess接口，而基于链表的没有。</p>
<p>对于没有实现RandomAccess接口的List而言，其随机访问性能是极低的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序性能优化（三）：常用优化组件和方法</title>
    <url>/2020/09/23/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E7%BB%84%E4%BB%B6%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本篇文章是葛一鸣《Java程序性能优化》读书笔记的第三篇，主要内容有常用的优化组件和方法，以及常用的优化思想。<a id="more"></a></p>
<h3 id="缓冲-buffer">缓冲（Buffer）</h3>
<p>缓冲区是一块特定的内存区域，能够缓解应用程序上下层之间的性能差异，提供系统的性能。缓冲最常用的场景是提供I/O的速度，JDK的很多I/O组件都提供了缓冲功能，如BufferedWriter。</p>
<p>缓冲区不宜过小，过小无法起到缓冲作用，也不宜过大，过大会浪费系统内存，增加GC负担。</p>
<p>由于I/O操作很容易成为性能瓶颈，故尽可能在I/O读写中加入缓冲组件，以提高系统的性能。</p>
<h3 id="缓存-cache">缓存（Cache）</h3>
<p>缓存也是一块为了提高系统性能而开辟的内存空间，主要作用是暂存数据处理结果，并提供下次访问使用。缓存可以保存一些来之不易的数据或计算结果，当需要再次使用时，可以从缓冲中低成本地获取，而不需要再占用宝贵的系统资源。</p>
<h3 id="池">池</h3>
<p>对象池化是一种非常常用的系统优化技术，核心思想是：如果一个类被频繁请求使用，那么不必每次都生成一个实例，可以将这个类的一些实例保存在一个池中，待需要使用的时候直接从池中获取。如线程池和数据库连接池。</p>
<p>对于经常使用，并且创建很费时的大型对象来说，可以使用对象池维护，这样不仅可以节省获得对象实例的成本，还可以减轻GC频繁回收这些对象产生的系统压力。</p>
<h3 id="并行替代串行">并行替代串行</h3>
<p>传统的串行程序比较不能发挥CPU的最大潜能，而并行可以将CPU性能发挥到极致。</p>
<h3 id="负载均衡">负载均衡</h3>
<p>如果应用并发数很多，单台计算机就无法承受，为了保证应用的服务质量，需要使用多台机器协同工作，将系统负载尽可能均匀地分配到各个机器上。</p>
<h3 id="时间换空间">时间换空间</h3>
<p>通常用于嵌入式设备，或者内存、硬盘空间不足的情况，通过牺牲CPU来获得原本需要更多内存或者硬盘空间才能完成的工作。</p>
<h3 id="空间换时间">空间换时间</h3>
<p>尝试使用更多的内存或者磁盘空间换取CPU资源或者网络资源，通过增加系统的内存消耗，来加快程序的运行速度。典型应用是缓存，在一些算法中也会选择空间换时间。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序性能优化（二）：设计优化之设计模式</title>
    <url>/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>本篇文章是葛一鸣《Java程序性能优化》读书笔记的第二篇，主要内容有常用的与性能相关的设计模式。<a id="more"></a></p>
<h3 id="设计模式">设计模式</h3>
<p>设计模式是对某一特定问题的成熟的解决方案。</p>
<h4 id="单例模式">单例模式</h4>
<p>确保系统中一个类只产生一个实例。对于频繁使用的对象，可以省略创建对象所花费的时间，另外，由于new操作的次数减少，对内存使用频率会降低，将减轻GC压力，缩短GC停顿时间。</p>
<p>单例类必须要有一个private访问级别的构造函数。可分为饿汉和懒汉两种类型的单例模式。</p>
<p>序列化和反序列化可能会破坏单例。</p>
<h4 id="代理模式">代理模式</h4>
<p>使用代理对象完成用户请求，屏蔽用户对真实对象的访问。使用代理模式可能是出于安全原因，也可能是为了提升系统性能，延迟加载真实对象。</p>
<p>代理模式的主要参与者有4个：</p>
<ul>
<li>主题接口：定义代理类和真实类的公共对外方法。</li>
<li>真实主题：真正实现业务逻辑的类。</li>
<li>代理类：用来代理和封装真实主题。</li>
<li>Main：客户端，使用代理类和主题接口完成一些工作。</li>
</ul>
<p>在系统启动时，将消耗资源最多的方法都使用代理模式分离，就可以加快系统的启动速度，减少用户等待的时间。</p>
<p>延迟加载的核心思想是：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的位置，只要在真正使用的时候才对它进行加载。</p>
<h5 id="动态代理">动态代理</h5>
<p>动态代理是指在运行时动态生成代理类，即代理类的字节码将在运行时生成并载入当前的ClassLoader。与静态代理类相比，动态类不需要为真实主题写一个形式上完全一样的封装类，其次，一些动态代理的生成方法甚至可以在运行时指定代理类的执行逻辑，从而大大提升系统的灵活性。</p>
<p>生成动态代理类的方法有：JDK自带的动态代理，CGLIB，Javassist或者ASM库。</p>
<p>实现动态代理的基本步骤：</p>
<p>根据指定的回调类生成Class字节码-----&gt;通过defineClass()将字节码定义为类-----&gt;使用反射机制生成该类的实例</p>
<h4 id="享元模式">享元模式</h4>
<p>享元模式以提高系统性能为目的，核心思想是：如果一个系统中存在多个相同的对象，那么只需共享一份对象的拷贝，而不必为每一次使用都创建新的对象。在享元模式中，常常会有一个工厂类来维护和创建对象。</p>
<p>享元模式对性能提升的主要帮助有两点：</p>
<ul>
<li>可以节省重复创建对象的开销。</li>
<li>由于创建对象的数量减少，所以对系统内存的需求也减小，使得GC的压力也相应地降低，进而使得系统拥有一个更健康的内存结构和更快的反应速度。</li>
</ul>
<p>享元模式的主要角色有：</p>
<ul>
<li>享元工厂：用以创建具体享元类，维护相同的享元对象。</li>
<li>抽象享元：定义需共享的对象的业务接口。</li>
<li>具体享元类：实现抽象享元类的接口，完成某一具体逻辑。</li>
<li>Main：使用享元模式的组件，通过享元工厂取得享元对象。</li>
</ul>
<p>结构如图所示：</p>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.PNG" alt="享元模式类图"></p>
<h4 id="装饰者模式">装饰者模式</h4>
<p>装饰者模式可以动态添加对象功能，通过委托机制，复用系统中的各个组件，在运行时将功能组件进行叠加，从而构造一个拥有所以这些组件的功能。装饰者模式可以有效分离性能组件和功能组件，从而提升模块的可维护性并增加模块的复用性。</p>
<p>装饰者模式的主要角色有：</p>
<ul>
<li>组件接口：是装饰者和被装饰者的超类或者接口，定义了被装饰者的核心功能和装饰者需要加强的功能点。</li>
<li>具体组件：具体组件实现了组件接口的核心方法，完成具体的业务逻辑，也是被装饰的对象。</li>
<li>装饰者：实现组件接口，并持有一个具体的被装饰者对象。</li>
<li>具体装饰者：具体实现装饰的业务逻辑。</li>
</ul>
<p>JDK中的OutputStream和InputStream类族的实现是装饰者模式的典型应用，通过嵌套的方式不断将对象聚合起来，工作流程如图所示：</p>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.PNG" alt="观察者模式的工作流程"></p>
<h4 id="观察者模式">观察者模式</h4>
<p>观察者模式可以用于事件监听、通知发布等场合，可以确保观察者在不使用轮询监控的情况下，及时收到相关消息和事件。</p>
<p>观察者模式的主要角色如下：</p>
<ul>
<li>主题接口：被观察的对象状态发生改变时，会将这个变化通知观察者，它维护了观察者所需要依赖的状态。</li>
<li>具体主题：实现了主题接口中的方法，如新增观察者、删除观察者和通知观察者，其内部维护一个观察者列表。</li>
<li>观察者接口：定义了观察者的基本方法，当依赖状态发生改变时，主题接口会调用观察者的update()方法。</li>
<li>具体观察者，实现了观察者接口的update()方法。</li>
</ul>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.PNG" alt="观察者模式结构"></p>
<h4 id="value-object-模式">Value Object 模式</h4>
<p>Value Object模式提倡将一个对象的各个属性进行封装，将封装后的对象在网络中传递，从而使系统拥有更好的交互模型，并且减少网络通信数据，从而提高系统性能。对象必须是一个可串行化的对象。</p>
<h4 id="业务代理模式">业务代理模式</h4>
<p>业务代理模式将一组由远程方法调用构成的业务流程，封装在一个位于展示层的代理类中，即将一些业务流程封装在前台系统，为系统性能优化提供了基础平台。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序性能优化（一）：Java性能调优概述</title>
    <url>/2020/09/14/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>本系列文章为葛一鸣《Java程序性能优化》的学习笔记，本篇为第1章，Java性能调优概述，主要内容有：程序性能指标、调优手段等。<a id="more"></a></p>
<h3 id="程序的性能">程序的性能</h3>
<p>一般情况，程序的性能通过几个方面来表现：</p>
<ul>
<li>执行速度：程序反映是否迅速，相应时间是否够短。</li>
<li>内存分配：内存分配是否合理，是否消耗过多内存或者存在内存泄漏。</li>
<li>启动时间：程序从启动到可以正常处理业务所花费时间。</li>
<li>负载承受能力：当系统压力上升时，系统的执行速度、响应时间的上升曲线是否平缓。</li>
</ul>
<p>为了能够进行性能分析，需要有可以定量评测的性能指标，如下：</p>
<ul>
<li>执行时间：程序开始运行到结束所用时间。</li>
<li>CPU时间：函数或线程所占用的时间。</li>
<li>内存分配：程序运行时所占用的内存空间。</li>
<li>磁盘吞吐量：I/O的使用情况。</li>
<li>网络吞吐量：网络的使用情况。</li>
<li>响应时间：系统对事件做出响应的时间，越短越好。</li>
</ul>
<h3 id="性能瓶颈">性能瓶颈</h3>
<p>根据木桶原理，系统的最终性能取决于性能表现最差的组件，故在提升系统整体性能时，必须对系统中表现最差的组件进行优化。</p>
<p>最有可能成为系统性能瓶颈的计算资源如下：</p>
<ul>
<li>磁盘I/O：磁盘I/O读写比内存慢很多，故低效的I/O操作会拖累整个系统。</li>
<li>网络操作：与磁盘I/O类似，网络环境存在不确定性。</li>
<li>CPU：对计算资源要求较高的应用需要大量占用CPU，对CPU的争夺会导致性能问题，如科学计算、3D渲染等应用。</li>
<li>异常：Java应用的异常捕获和处理非常消耗资源。</li>
<li>数据库：读写耗时，同步操作缓慢。</li>
<li>锁竞争：对于高并发程序，锁竞争会明显增加上下文的切换，浪费CPU资源。</li>
<li>内存：高频率的内存交换和扫描，较少见，内存相对于磁盘容量较小。</li>
</ul>
<h3 id="amdahl定律">Amdahl定律</h3>
<p>Amdahl定律定义了串行系统并行化后加速比的计算公式和理论上限。</p>
<p><strong>加速比 = 优化前系统耗时 / 优化后系统耗时</strong></p>
<p>加速比越高，优化效果越明显。</p>
<p>Amdahl定律给出了加速比与系统并行度和处理器数量的关系，设加速比为<em>Speedup</em>，系统内必须串行化的程序比重为<em>F</em>，CPU处理器数量为<em>N</em>，则有：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>p</mi><mo>&lt;</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>F</mi><mo>+</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>F</mi></mrow><mi>N</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">Speedup &lt;= \frac{1}{F + \frac{1 - F}{N}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.428771em;vertical-align:-1.1073309999999998em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2376690000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1073309999999998em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>根据该关系可以知道：使用多核CPU对系统进行优化，优化的效果取决于CPU的数量以及系统中的串行化程序的比重。CPU数量越多，串行化比重越低，则优化效果越好。</p>
<h3 id="性能调优的层次">性能调优的层次</h3>
<p>可以从系统的各个角度和层次对系统进行优化，从而提升系统性能。</p>
<h4 id="设计调优">设计调优</h4>
<p>设计调优位于所有调优手段的最上层，对系统性能的影响是最大的。设计优化的显著特点是：可以规避某一个组件的性能问题，而非改良该组件的实现。</p>
<h4 id="代码优化">代码优化</h4>
<p>对程序代码进行优化和改进，是对系统性能产生最直接影响的优化方法。</p>
<h4 id="jvm调优">JVM调优</h4>
<p>JVM调优通常在软件开发后期进行，JVM的各项参数会直接影响到Java程序的性能，比如堆大小、垃圾回收策略等，需要依据程序的特点，设置合理的JVM启动参数。</p>
<h4 id="数据库调优">数据库调优</h4>
<p>在应用层对SQL语句进行优化，对数据库进行优化，对数据库软件进行优化。</p>
<h4 id="操作系统优化">操作系统优化</h4>
<p>作为程序运行的基础平台，操作系统的性能对应用系统也有较大影响，不同类型的操作系统的调优手段和参数会有所不同。</p>
<h3 id="基本调优策略和手段">基本调优策略和手段</h3>
<p>在对系统进行调优时 ，应该找到导致问题的性能瓶颈，对其进行优化，就能从根本上提升性能。</p>
<p>优化的一般步骤如下：</p>
<p><img src="/2020/09/14/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4.PNG" alt="性能优化的一般步骤"></p>
<p>软件优化需要在软件功能、正确性和可维护性取得平衡，而不应该过分追求软件性能。任何优化都是为了解决具体的软件问题。性能优化必须有明确的目标，不能为了优化而优化。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven基础</title>
    <url>/2020/08/30/Maven%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。<a id="more"></a></p>
<h3 id="maven能做什么">Maven能做什么</h3>
<p>构建工程，管理jar包，编译代码，自动运行单元测试，打包，生成报表，部署项目，生成Web站点。</p>
<h3 id="maven优势">Maven优势</h3>
<p>传统web项目，jar包在项目中；</p>
<p>maven开发的项目，jar包不在项目中，而是根据jar包的坐标从jar包仓库中查找。</p>
<p>能够减少项目磁盘空间（特别是多个项目的时候，传统下每个项目都有jar包，maven是共用仓库中的）。</p>
<h3 id="项目的一键构建">项目的一键构建</h3>
<p>项目从编译、测试、运行、打包、安装、部署整个过程都可以交给maven进行管理，这个过程称为构建。</p>
<p>maven规范化构建流程如下：</p>
<p>清理  —&gt;   编译  —&gt;   测试  —&gt;   报告  —&gt;   打包  —&gt;   部署</p>
<h3 id="仓库种类和彼此关系">仓库种类和彼此关系</h3>
<p>仓库分三类：本地仓库，远程仓库（私服），中央仓库</p>
<p>默认情况下：先找本地，本地没有再去中央</p>
<p>公司使用：先找本地，本地没有找远程，远程可以从本地和中央下jar包</p>
<h3 id="maven标准目录结构">maven标准目录结构</h3>
<p>项目可分为：核心代码部分，配置文件部分，测试代码部分，测试配置文件部分</p>
<p>maven目录结构：</p>
<p>src/main/java  核心代码部分</p>
<p>src/main/resources  配置文件部分</p>
<p>src/test/java  测试代码部分</p>
<p>src/test/resources  测试配置文件部分</p>
<p>src/main/webapp  页面资源，js，css，图片等</p>
<h3 id="maven常用命令">maven常用命令</h3>
<p>mvn clean   清除项目编译信息，删除target文件夹</p>
<p>mvn compile   编译正式的代码，创建target文件夹</p>
<p>mvn test   编译正式的代码和测试文件夹下的代码</p>
<p>mvn package   对项目正式、测试的代码进行编译，同时打包并放置于target文件夹</p>
<p>mvn install   相当于mvn package后，将生成的包安装到本地仓库</p>
<h3 id="maven生命周期">maven生命周期</h3>
<p>清理生命周期：</p>
<p>clean</p>
<p>默认生命周期：</p>
<p>编译（compile）</p>
<p>测试（test）</p>
<p>打包（package）</p>
<p>安装（install）</p>
<p>发布（deploy）</p>
<p>每一步命令都会包含前面所有的命令</p>
<h3 id="maven概念模型图">maven概念模型图</h3>
<p><img src="/2020/08/30/Maven%E5%9F%BA%E7%A1%80/maven%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt></p>
<p>项目对象模型（POM）包括：</p>
<p>项目自身信息、项目运行所依赖的jar包信息、项目运行环境信息，比如jdk、tomcat信息</p>
<p>依赖管理模型（Dependency）：</p>
<p>公司组织的名称、项目名、版本号</p>
<p>一键构建：</p>
<p>每一个构造项目的命令都对应了maven底层一个插件</p>
<h3 id="maven依赖范围">maven依赖范围</h3>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th>对于编译classpath有效</th>
<th>对于测试classpath有效</th>
<th>对于运行classpath有效</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>spring-core</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>JDBC</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>本地仓库之外的类库</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo框架介绍</title>
    <url>/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Dubbo是阿里巴巴公司开源的一款高性能Java RPC框架，提供了三个核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。<a id="more"></a></p>
<h3 id="背景">背景</h3>
<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.jpg" alt="架构演进"></p>
<h5 id="单一应用结构">单一应用结构</h5>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<h5 id="垂直应用架构">垂直应用架构</h5>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h5 id="分布式服务架构">分布式服务架构</h5>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h5 id="流动计算架构">流动计算架构</h5>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="需求">需求</h3>
<p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/dubbo-service-governance.jpg" alt="Dubbo服务治理"></p>
<p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p>
<p><strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</strong> 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p>
<p><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。</p>
<p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>
<p>以上是 Dubbo 最基本的几个需求。</p>
<h3 id="架构">架构</h3>
<p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/architecture.png" alt="Dubbo架构"></p>
<h5 id="节点说明">节点说明</h5>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<h5 id="调用关系说明">调用关系说明</h5>
<p>​	0. 服务容器负责启动，加载，运行服务提供者。</p>
<p>​	1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>​	2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>​	3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>​	4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>​	5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h3 id="用法">用法</h3>
<h5 id="本地服务-spring-配置">本地服务 Spring 配置</h5>
<p>local.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxServiceImpl”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxAction”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxAction”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“xxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="远程服务-spring-配置">远程服务 Spring 配置</h5>
<p>在本地服务的基础上，只需做简单配置，即可完成远程化：</p>
<ul>
<li>将上面的 <code>local.xml</code> 配置拆分成两份，将服务定义部分放在服务提供方 <code>remote-provider.xml</code>，将服务引用部分放在服务消费方 <code>remote-consumer.xml</code>。</li>
<li>并在提供方增加暴露服务配置 <code>&lt;dubbo:service&gt;</code>，在消费方增加引用服务配置 <code>&lt;dubbo:reference&gt;</code>。</li>
</ul>
<p>remote-provider.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 和本地服务一样实现远程服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxServiceImpl”</span> /&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 增加暴露远程服务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>remote-consumer.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 增加引用远程服务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和本地服务一样使用远程服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxAction”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxAction”</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“xxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<br>
<p>参考：</p>
<p><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">Dubbo官方文档</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>快速弄懂分布式和微服务的关系</title>
    <url>/2020/08/10/%E5%BF%AB%E9%80%9F%E5%BC%84%E6%87%82%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>分布式和微服务是什么关系？简单来说，分布式和微服务的概念比较相似，微服务是一种特殊的分布式。但是分布式和微服务在架构、作用和粒度上有所区别。因此，两者的关系是既相互联系又相互区别。<a id="more"></a></p>
<h3 id="微服务">微服务</h3>
<p>微服务的意思是将模块拆分成一个个独立的服务单元，通过接口来实现数据的交互。简单来说微服务就是很小的服务，小到一个服务只对应一个<strong>单一的功能</strong>，只做一件事。这个服务可以单独部署运行，服务之间可以通过RPC来进行交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</p>
<h3 id="分布式">分布式</h3>
<p>分布式服务指服务是分散部署在不同的机器上的，一个服务可能负责<strong>几个功能</strong>，是一种面向SOA架构的，服务之间也是通过RPC来交互或者是WebService来交互的。逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署。生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p>
<h3 id="关系">关系</h3>
<p>分布式只是一种手段，把不同的机器分散在不同的地方，然后这些机器间相互协助完成业务。微服务是一种特殊的分布式，换句话说，微服务架构是分布式服务架构的子集。微服务架构通过更细粒度的服务切分，使得整个系统的迭代速度并行程度更高，但是运维的复杂度和性能会随着服务的粒度更细而增加。微服务重在解耦合，使每个模块都独立。分布式重在资源共享与加快计算机计算速度。</p>
<h3 id="区别">区别</h3>
<p>（1）架构不同：微服务的设计是为了不因为某个模块的升级和BUG影响现有的系统业务。微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。</p>
<p>（2）作用不同：分布式是不同模块部署在不同服务器上，分布式主要解决的是网站高并发带来问题。微服务是各服务可独立应用，组合服务也可系统应用。</p>
<p>（3）粒度不同：微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高。</p>
<br>
<p>分布式服务最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常类型</title>
    <url>/2020/07/15/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在Java语言规范中，将派生于Error或者RuntimeException的异常称为Unchecked Exception（非受检异常），所有其他的异常则称为Checked Exception（受检异常）。<a id="more"></a></p>
<h3 id="checked-exception">Checked Exception</h3>
<p>Checked Exception是开发者必须在代码中进行恰当处理的Exception，而且<strong>编译器会强制开发者对其进行处理</strong>，我们可以使用<code>catch</code>语句捕获这些异常，或者在方法声明处使用<code>throws</code>抛出该异常。</p>
<p>通常情况下，Checked Exception的发生是超出开发者控制范围的，比如网络连接失败会抛出的<code>IOException</code>，但是我们的程序必须能够预料到这些可能发生的异常，并对其进行处理，保证程序不会在运行过程中崩溃，这也是编译器强制我们对Checked Exception进行处理的原因。假如在文件传输过程中网络中断，我们的程序应该能够捕获到这种异常并进行处理，尝试重新传输文件。</p>
<p>当我们希望方法在被调用时需要明确地处理一些特殊情况时，就应该使用Checked Exception</p>
<h3 id="unchecked-exception">Unchecked Exception</h3>
<p>Unchecked Exception的发生有一部分是因为开发者的代码逻辑错误造成的，比如<code>NullPointerException</code>这种可以通过检查是否为null来避免的异常。</p>
<p>但是也有一部分跟开发者没关系，它们是<code>java.lang.Error</code>的子类，我们不能够预料这部分异常的发生，所以并<strong>不强制</strong>我们对其进行处理，但如果不捕获，在运行期间如果发生异常就会中断程序的执行。比如<code>OutOfMemoryError</code>可能发生在任意一个实例对象创建的时候，但我们不可能在每个实例对象创建的时候都使用<code>catch</code>语句去捕获异常。</p>
<h3 id="例子">例子</h3>
<p>下面的例子，由于我们没有对Checked Exception进行处理而导致编译失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使上面的代码可以正确编译，我们可以在<code>try/catch</code>块中捕获相应的异常，或者使用<code>throws</code>在main方法声明处抛出异常。</p>
<p>但是如果在main方法内部抛出一个Unchecked Exception，依然可以正确编译，如下面的例子，这是因为Unchecked Exception无法在编译期间被发现，所以即使不处理也能够正常编译。这点在IDE中也可以直接看到效果，如果是能够在编译期间被发现的异常，IDE会有所提示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exception类层次结构">Exception类层次结构</h3>
<p><code>java.lang.Throwable</code>类是一个Checked Exception，它有两个子类：<code>java.lang.Exception</code>和<code>java.lang.Error</code>，Error类是Unchecked Exception，Exception类则是Checked Exception</p>
<p>。</p>
<p>Exception类有一个Unchecked Exception子类：<code>java.lang.RuntimeException</code>，像<code>NullPointerException</code>和<code>ClassCastException</code>都是RuntimeException的子类。RuntimeException和Error的所有子类都是Unchecked Exception，其他的则都是Checked Exception，如下图所示。</p>
<p><img src="/2020/07/15/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/exception-class-hierarchy.png" alt="exception-class-hierarchy"></p>
<p>如果我们自定义一个异常类，那它是Checked Exception还是Unchecked Exception取决于其父类的类型。在对Checked Exception进行catch操作时，需要遵循一定的规则：在catch块中捕获的异常，必须在try块中有出现这种异常的可能性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(java.io.IOException ioe) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子并不能编译成功，这是因为在try块中永远不会抛出IOException。但如果catch块中捕获的是一个Unchecked Exception，那么就不会有这种问题，因为编译器不能检查出Unchecked Exception，那么它倾向于认为catch块中的捕获是能够捕获到的。</p>
<p>Exception和Throwable这两个类比较特殊，虽然它们都是Checked Exception，但是我们依然可以在catch块中捕获它们，即使它们并没有在try块中抛出异常的可能性，比如下面的代码就能够正常编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exception和Throwable之所以比较特殊是因为它们这两个类都有Unchecked Exception类型的子类，所以编译器允许我们捕获它们（编译器认为我们在捕获的是Unchecked Exception）。</p>
<h3 id="jvm和程序异常">JVM和程序异常</h3>
<p>JVM Exception是由JVM自己抛出的异常。例如，我们调用null对象的方法时，JVM会抛出<code>NullPointerException</code>,或者出现10除以0的情况时，JVM会抛出<code>ArithmeticException</code>，这些异常都是由JVM自动抛出的。</p>
<p>除了JVM异常，其他的都是程序异常。我们可以显式使用<code>throw</code>抛出异常，比如<code>NumberFormatException</code>可能被方法<code>Integer.parseInt</code>或<code>Float.parseFloat</code>抛出，都是程序异常，我们可以在Integer类的parseInt方法的实现中找到以下声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM不会主动抛出这种类型的异常（程序异常），这些异常都是在程序中使用<code>throw</code>显式抛出，当然也可以在程序中显式抛出JVM Exception，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"I told you s shouldn't be null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但通常来说，JVM Exception是不会被开发者抛出的，一般由JVM自己主动抛出，所有的JVM Exception都是Unchecked Exception，而程序异常则可能是Checked Exception或Unchecked Exception。</p>
<h3 id="争论">争论</h3>
<p>关于Checked Exception和Unchecked Exception其实争论是比较大的，Checked Exception的本意是在编译时检查是否存在异常处理程序，强制开发者对异常进行处理，从而减少未正确处理的异常数量。但是，也有观点支持Unchecked Exception，认为沿调用栈向上传播的Checked Exception破坏了顶层的方法，因为这些方法必须声明抛出所有它们调用的方法抛出的异常，而且过多的try/catch块并不能提高开发者的工作效率，还影响代码可读性，Unchecked Exception可以将异常处理集中在少数几个类进行处理，减少无用的try/catch代码块。</p>
<h3 id="总结">总结</h3>
<p>Checked Exception必须被显式地捕获或者抛出，而Unchecked Exception则可以不必捕获或抛出。两者从功能的角度来看是等价的，并不存在哪个更强大，选择哪个的原因更多还是看个人习惯或者组织规定问题。</p>
<br>
<p>参考：</p>
<p>1、<a href="http://www.hacktrix.com/checked-and-unchecked-exceptions-in-java" target="_blank" rel="noopener">Checked and Unchecked Exceptions in Java</a></p>
<p>2、<a href="https://blog.csdn.net/kingzone_2008/article/details/8535287" target="_blank" rel="noopener">Java异常：选择Checked Exception还是Unchecked Exception?</a></p>
<p>3、<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-11.html#jls-11.2" target="_blank" rel="noopener">Compile-Time Checking of Exceptions</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
</search>
