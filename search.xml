<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java程序性能优化（二）：设计优化之设计模式</title>
    <url>/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>本篇文章是葛一鸣《Java程序性能优化》读书笔记的第二篇，主要内容有常用的与性能相关的设计模式。<a id="more"></a></p>
<h3 id="设计模式">设计模式</h3>
<p>设计模式是对某一特定问题的成熟的解决方案。</p>
<h4 id="单例模式">单例模式</h4>
<p>确保系统中一个类只产生一个实例。对于频繁使用的对象，可以省略创建对象所花费的时间，另外，由于new操作的次数减少，对内存使用频率会降低，将减轻GC压力，缩短GC停顿时间。</p>
<p>单例类必须要有一个private访问级别的构造函数。可分为饿汉和懒汉两种类型的单例模式。</p>
<p>序列化和反序列化可能会破坏单例。</p>
<h4 id="代理模式">代理模式</h4>
<p>使用代理对象完成用户请求，屏蔽用户对真实对象的访问。使用代理模式可能是出于安全原因，也可能是为了提升系统性能，延迟加载真实对象。</p>
<p>代理模式的主要参与者有4个：</p>
<ul>
<li>主题接口：定义代理类和真实类的公共对外方法。</li>
<li>真实主题：真正实现业务逻辑的类。</li>
<li>代理类：用来代理和封装真实主题。</li>
<li>Main：客户端，使用代理类和主题接口完成一些工作。</li>
</ul>
<p>在系统启动时，将消耗资源最多的方法都使用代理模式分离，就可以加快系统的启动速度，减少用户等待的时间。</p>
<p>延迟加载的核心思想是：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的位置，只要在真正使用的时候才对它进行加载。</p>
<h5 id="动态代理">动态代理</h5>
<p>动态代理是指在运行时动态生成代理类，即代理类的字节码将在运行时生成并载入当前的ClassLoader。与静态代理类相比，动态类不需要为真实主题写一个形式上完全一样的封装类，其次，一些动态代理的生成方法甚至可以在运行时指定代理类的执行逻辑，从而大大提升系统的灵活性。</p>
<p>生成动态代理类的方法有：JDK自带的动态代理，CGLIB，Javassist或者ASM库。</p>
<p>实现动态代理的基本步骤：</p>
<p>根据指定的回调类生成Class字节码-----&gt;通过defineClass()将字节码定义为类-----&gt;使用反射机制生成该类的实例</p>
<h4 id="享元模式">享元模式</h4>
<p>享元模式以提高系统性能为目的，核心思想是：如果一个系统中存在多个相同的对象，那么只需共享一份对象的拷贝，而不必为每一次使用都创建新的对象。在享元模式中，常常会有一个工厂类来维护和创建对象。</p>
<p>享元模式对性能提升的主要帮助有两点：</p>
<ul>
<li>可以节省重复创建对象的开销。</li>
<li>由于创建对象的数量减少，所以对系统内存的需求也减小，使得GC的压力也相应地降低，进而使得系统拥有一个更健康的内存结构和更快的反应速度。</li>
</ul>
<p>享元模式的主要角色有：</p>
<ul>
<li>享元工厂：用以创建具体享元类，维护相同的享元对象。</li>
<li>抽象享元：定义需共享的对象的业务接口。</li>
<li>具体享元类：实现抽象享元类的接口，完成某一具体逻辑。</li>
<li>Main：使用享元模式的组件，通过享元工厂取得享元对象。</li>
</ul>
<p>结构如图所示：</p>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.PNG" alt="享元模式类图"></p>
<h4 id="装饰者模式">装饰者模式</h4>
<p>装饰者模式可以动态添加对象功能，通过委托机制，复用系统中的各个组件，在运行时将功能组件进行叠加，从而构造一个拥有所以这些组件的功能。装饰者模式可以有效分离性能组件和功能组件，从而提升模块的可维护性并增加模块的复用性。</p>
<p>装饰者模式的主要角色有：</p>
<ul>
<li>组件接口：是装饰者和被装饰者的超类或者接口，定义了被装饰者的核心功能和装饰者需要加强的功能点。</li>
<li>具体组件：具体组件实现了组件接口的核心方法，完成具体的业务逻辑，也是被装饰的对象。</li>
<li>装饰者：实现组件接口，并持有一个具体的被装饰者对象。</li>
<li>具体装饰者：具体实现装饰的业务逻辑。</li>
</ul>
<p>JDK中的OutputStream和InputStream类族的实现是装饰者模式的典型应用，通过嵌套的方式不断将对象聚合起来，工作流程如图所示：</p>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.PNG" alt="观察者模式的工作流程"></p>
<h4 id="观察者模式">观察者模式</h4>
<p>观察者模式可以用于事件监听、通知发布等场合，可以确保观察者在不使用轮询监控的情况下，及时收到相关消息和事件。</p>
<p>观察者模式的主要角色如下：</p>
<ul>
<li>主题接口：被观察的对象状态发生改变时，会将这个变化通知观察者，它维护了观察者所需要依赖的状态。</li>
<li>具体主题：实现了主题接口中的方法，如新增观察者、删除观察者和通知观察者，其内部维护一个观察者列表。</li>
<li>观察者接口：定义了观察者的基本方法，当依赖状态发生改变时，主题接口会调用观察者的update()方法。</li>
<li>具体观察者，实现了观察者接口的update()方法。</li>
</ul>
<p><img src="/2020/09/17/Java%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.PNG" alt="观察者模式结构"></p>
<h4 id="value-object-模式">Value Object 模式</h4>
<p>Value Object模式提倡将一个对象的各个属性进行封装，将封装后的对象在网络中传递，从而使系统拥有更好的交互模型，并且减少网络通信数据，从而提高系统性能。对象必须是一个可串行化的对象。</p>
<h4 id="业务代理模式">业务代理模式</h4>
<p>业务代理模式将一组由远程方法调用构成的业务流程，封装在一个位于展示层的代理类中，即将一些业务流程封装在前台系统，为系统性能优化提供了基础平台。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 程序性能优化（一）：Java性能调优概述</title>
    <url>/2020/09/14/Java-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>本系列文章为葛一鸣《Java程序性能优化》的学习笔记，本篇为第1章，Java性能调优概述，主要内容有：程序性能指标、调优手段等。<a id="more"></a></p>
<h3 id="程序的性能"><a href="#程序的性能" class="headerlink" title="程序的性能"></a>程序的性能</h3><p>一般情况，程序的性能通过几个方面来表现：</p>
<ul>
<li>执行速度：程序反映是否迅速，相应时间是否够短。</li>
<li>内存分配：内存分配是否合理，是否消耗过多内存或者存在内存泄漏。</li>
<li>启动时间：程序从启动到可以正常处理业务所花费时间。</li>
<li>负载承受能力：当系统压力上升时，系统的执行速度、响应时间的上升曲线是否平缓。</li>
</ul>
<p>为了能够进行性能分析，需要有可以定量评测的性能指标，如下：</p>
<ul>
<li>执行时间：程序开始运行到结束所用时间。</li>
<li>CPU时间：函数或线程所占用的时间。</li>
<li>内存分配：程序运行时所占用的内存空间。</li>
<li>磁盘吞吐量：I/O的使用情况。</li>
<li>网络吞吐量：网络的使用情况。</li>
<li>响应时间：系统对事件做出响应的时间，越短越好。</li>
</ul>
<h3 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h3><p>根据木桶原理，系统的最终性能取决于性能表现最差的组件，故在提升系统整体性能时，必须对系统中表现最差的组件进行优化。</p>
<p>最有可能成为系统性能瓶颈的计算资源如下：</p>
<ul>
<li>磁盘I/O：磁盘I/O读写比内存慢很多，故低效的I/O操作会拖累整个系统。</li>
<li>网络操作：与磁盘I/O类似，网络环境存在不确定性。</li>
<li>CPU：对计算资源要求较高的应用需要大量占用CPU，对CPU的争夺会导致性能问题，如科学计算、3D渲染等应用。</li>
<li>异常：Java应用的异常捕获和处理非常消耗资源。</li>
<li>数据库：读写耗时，同步操作缓慢。</li>
<li>锁竞争：对于高并发程序，锁竞争会明显增加上下文的切换，浪费CPU资源。</li>
<li>内存：高频率的内存交换和扫描，较少见，内存相对于磁盘容量较小。</li>
</ul>
<h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p>Amdahl定律定义了串行系统并行化后加速比的计算公式和理论上限。</p>
<p><strong>加速比 = 优化前系统耗时 / 优化后系统耗时</strong></p>
<p>加速比越高，优化效果越明显。</p>
<p>Amdahl定律给出了加速比与系统并行度和处理器数量的关系，设加速比为<em>Speedup</em>，系统内必须串行化的程序比重为<em>F</em>，CPU处理器数量为<em>N</em>，则有：<br>$$<br>Speedup &lt;= \frac{1}{F + \frac{1 - F}{N}}<br>$$<br>根据该关系可以知道：使用多核CPU对系统进行优化，优化的效果取决于CPU的数量以及系统中的串行化程序的比重。CPU数量越多，串行化比重越低，则优化效果越好。</p>
<h3 id="性能调优的层次"><a href="#性能调优的层次" class="headerlink" title="性能调优的层次"></a>性能调优的层次</h3><p>可以从系统的各个角度和层次对系统进行优化，从而提升系统性能。</p>
<h4 id="设计调优"><a href="#设计调优" class="headerlink" title="设计调优"></a>设计调优</h4><p>设计调优位于所有调优手段的最上层，对系统性能的影响是最大的。设计优化的显著特点是：可以规避某一个组件的性能问题，而非改良该组件的实现。</p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>对程序代码进行优化和改进，是对系统性能产生最直接影响的优化方法。</p>
<h4 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h4><p>JVM调优通常在软件开发后期进行，JVM的各项参数会直接影响到Java程序的性能，比如堆大小、垃圾回收策略等，需要依据程序的特点，设置合理的JVM启动参数。</p>
<h4 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h4><p>在应用层对SQL语句进行优化，对数据库进行优化，对数据库软件进行优化。</p>
<h4 id="操作系统优化"><a href="#操作系统优化" class="headerlink" title="操作系统优化"></a>操作系统优化</h4><p>作为程序运行的基础平台，操作系统的性能对应用系统也有较大影响，不同类型的操作系统的调优手段和参数会有所不同。</p>
<h3 id="基本调优策略和手段"><a href="#基本调优策略和手段" class="headerlink" title="基本调优策略和手段"></a>基本调优策略和手段</h3><p>在对系统进行调优时 ，应该找到导致问题的性能瓶颈，对其进行优化，就能从根本上提升性能。</p>
<p>优化的一般步骤如下：</p>
<p><img src="/2020/09/14/Java-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4.PNG" alt="性能优化的一般步骤"></p>
<p>软件优化需要在软件功能、正确性和可维护性取得平衡，而不应该过分追求软件性能。任何优化都是为了解决具体的软件问题。性能优化必须有明确的目标，不能为了优化而优化。</p>
<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven基础</title>
    <url>/2020/08/30/Maven%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。<a id="more"></a></p>
<h3 id="Maven能做什么"><a href="#Maven能做什么" class="headerlink" title="Maven能做什么"></a>Maven能做什么</h3><p>构建工程，管理jar包，编译代码，自动运行单元测试，打包，生成报表，部署项目，生成Web站点。</p>
<h3 id="Maven优势"><a href="#Maven优势" class="headerlink" title="Maven优势"></a>Maven优势</h3><p>传统web项目，jar包在项目中；</p>
<p>maven开发的项目，jar包不在项目中，而是根据jar包的坐标从jar包仓库中查找。</p>
<p>能够减少项目磁盘空间（特别是多个项目的时候，传统下每个项目都有jar包，maven是共用仓库中的）。</p>
<h3 id="项目的一键构建"><a href="#项目的一键构建" class="headerlink" title="项目的一键构建"></a>项目的一键构建</h3><p>项目从编译、测试、运行、打包、安装、部署整个过程都可以交给maven进行管理，这个过程称为构建。</p>
<p>maven规范化构建流程如下：</p>
<p>清理  —&gt;   编译  —&gt;   测试  —&gt;   报告  —&gt;   打包  —&gt;   部署</p>
<h3 id="仓库种类和彼此关系"><a href="#仓库种类和彼此关系" class="headerlink" title="仓库种类和彼此关系"></a>仓库种类和彼此关系</h3><p>仓库分三类：本地仓库，远程仓库（私服），中央仓库</p>
<p>默认情况下：先找本地，本地没有再去中央</p>
<p>公司使用：先找本地，本地没有找远程，远程可以从本地和中央下jar包</p>
<h3 id="maven标准目录结构"><a href="#maven标准目录结构" class="headerlink" title="maven标准目录结构"></a>maven标准目录结构</h3><p>项目可分为：核心代码部分，配置文件部分，测试代码部分，测试配置文件部分</p>
<p>maven目录结构：</p>
<p>src/main/java  核心代码部分</p>
<p>src/main/resources  配置文件部分</p>
<p>src/test/java  测试代码部分</p>
<p>src/test/resources  测试配置文件部分</p>
<p>src/main/webapp  页面资源，js，css，图片等</p>
<h3 id="maven常用命令"><a href="#maven常用命令" class="headerlink" title="maven常用命令"></a>maven常用命令</h3><p>mvn clean   清除项目编译信息，删除target文件夹</p>
<p>mvn compile   编译正式的代码，创建target文件夹</p>
<p>mvn test   编译正式的代码和测试文件夹下的代码</p>
<p>mvn package   对项目正式、测试的代码进行编译，同时打包并放置于target文件夹</p>
<p>mvn install   相当于mvn package后，将生成的包安装到本地仓库</p>
<h3 id="maven生命周期"><a href="#maven生命周期" class="headerlink" title="maven生命周期"></a>maven生命周期</h3><p>清理生命周期：</p>
<p>clean</p>
<p>默认生命周期：</p>
<p>编译（compile）</p>
<p>测试（test）</p>
<p>打包（package）</p>
<p>安装（install）</p>
<p>发布（deploy）</p>
<p>每一步命令都会包含前面所有的命令</p>
<h3 id="maven概念模型图"><a href="#maven概念模型图" class="headerlink" title="maven概念模型图"></a>maven概念模型图</h3><p><img src="/2020/08/30/Maven%E5%9F%BA%E7%A1%80/maven%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg" alt></p>
<p>项目对象模型（POM）包括：</p>
<p>项目自身信息、项目运行所依赖的jar包信息、项目运行环境信息，比如jdk、tomcat信息</p>
<p>依赖管理模型（Dependency）：</p>
<p>公司组织的名称、项目名、版本号</p>
<p>一键构建：</p>
<p>每一个构造项目的命令都对应了maven底层一个插件</p>
<h3 id="maven依赖范围"><a href="#maven依赖范围" class="headerlink" title="maven依赖范围"></a>maven依赖范围</h3><table>
<thead>
<tr>
<th>依赖范围</th>
<th>对于编译classpath有效</th>
<th>对于测试classpath有效</th>
<th>对于运行classpath有效</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>spring-core</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>JDBC</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>本地仓库之外的类库</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo框架介绍</title>
    <url>/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Dubbo是阿里巴巴公司开源的一款高性能Java RPC框架，提供了三个核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。<a id="more"></a></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.jpg" alt="架构演进"></p>
<h5 id="单一应用结构"><a href="#单一应用结构" class="headerlink" title="单一应用结构"></a>单一应用结构</h5><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<h5 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h5><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h5 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h5><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h5 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h5><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/dubbo-service-governance.jpg" alt="Dubbo服务治理"></p>
<p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p>
<p><strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</strong> 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p>
<p><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。</p>
<p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>
<p>以上是 Dubbo 最基本的几个需求。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2020/08/11/Dubbo%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/architecture.png" alt="Dubbo架构"></p>
<h5 id="节点说明"><a href="#节点说明" class="headerlink" title="节点说明"></a>节点说明</h5><table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<h5 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h5><p>​    0. 服务容器负责启动，加载，运行服务提供者。</p>
<p>​    1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>​    2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>​    3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>​    4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>​    5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h5 id="本地服务-Spring-配置"><a href="#本地服务-Spring-配置" class="headerlink" title="本地服务 Spring 配置"></a>本地服务 Spring 配置</h5><p>local.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxServiceImpl”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxAction”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxAction”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“xxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="远程服务-Spring-配置"><a href="#远程服务-Spring-配置" class="headerlink" title="远程服务 Spring 配置"></a>远程服务 Spring 配置</h5><p>在本地服务的基础上，只需做简单配置，即可完成远程化：</p>
<ul>
<li>将上面的 <code>local.xml</code> 配置拆分成两份，将服务定义部分放在服务提供方 <code>remote-provider.xml</code>，将服务引用部分放在服务消费方 <code>remote-consumer.xml</code>。</li>
<li>并在提供方增加暴露服务配置 <code>&lt;dubbo:service&gt;</code>，在消费方增加引用服务配置 <code>&lt;dubbo:reference&gt;</code>。</li>
</ul>
<p>remote-provider.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 和本地服务一样实现远程服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxServiceImpl”</span> /&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 增加暴露远程服务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>remote-consumer.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 增加引用远程服务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和本地服务一样使用远程服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxAction”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxAction”</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“xxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p>参考：</p>
<p><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">Dubbo官方文档</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>快速弄懂分布式和微服务的关系</title>
    <url>/2020/08/10/%E5%BF%AB%E9%80%9F%E5%BC%84%E6%87%82%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>分布式和微服务是什么关系？简单来说，分布式和微服务的概念比较相似，微服务是一种特殊的分布式。但是分布式和微服务在架构、作用和粒度上有所区别。因此，两者的关系是既相互联系又相互区别。<a id="more"></a></p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务的意思是将模块拆分成一个个独立的服务单元，通过接口来实现数据的交互。简单来说微服务就是很小的服务，小到一个服务只对应一个<strong>单一的功能</strong>，只做一件事。这个服务可以单独部署运行，服务之间可以通过RPC来进行交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>分布式服务指服务是分散部署在不同的机器上的，一个服务可能负责<strong>几个功能</strong>，是一种面向SOA架构的，服务之间也是通过RPC来交互或者是WebService来交互的。逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署。生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>分布式只是一种手段，把不同的机器分散在不同的地方，然后这些机器间相互协助完成业务。微服务是一种特殊的分布式，换句话说，微服务架构是分布式服务架构的子集。微服务架构通过更细粒度的服务切分，使得整个系统的迭代速度并行程度更高，但是运维的复杂度和性能会随着服务的粒度更细而增加。微服务重在解耦合，使每个模块都独立。分布式重在资源共享与加快计算机计算速度。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>（1）架构不同：微服务的设计是为了不因为某个模块的升级和BUG影响现有的系统业务。微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。</p>
<p>（2）作用不同：分布式是不同模块部署在不同服务器上，分布式主要解决的是网站高并发带来问题。微服务是各服务可独立应用，组合服务也可系统应用。</p>
<p>（3）粒度不同：微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高。</p>
<br>

<p>分布式服务最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常类型</title>
    <url>/2020/07/15/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在Java语言规范中，将派生于Error或者RuntimeException的异常称为Unchecked Exception（非受检异常），所有其他的异常则称为Checked Exception（受检异常）。<a id="more"></a></p>
<h3 id="Checked-Exception"><a href="#Checked-Exception" class="headerlink" title="Checked Exception"></a>Checked Exception</h3><p>Checked Exception是开发者必须在代码中进行恰当处理的Exception，而且<strong>编译器会强制开发者对其进行处理</strong>，我们可以使用<code>catch</code>语句捕获这些异常，或者在方法声明处使用<code>throws</code>抛出该异常。</p>
<p>通常情况下，Checked Exception的发生是超出开发者控制范围的，比如网络连接失败会抛出的<code>IOException</code>，但是我们的程序必须能够预料到这些可能发生的异常，并对其进行处理，保证程序不会在运行过程中崩溃，这也是编译器强制我们对Checked Exception进行处理的原因。假如在文件传输过程中网络中断，我们的程序应该能够捕获到这种异常并进行处理，尝试重新传输文件。</p>
<p>当我们希望方法在被调用时需要明确地处理一些特殊情况时，就应该使用Checked Exception</p>
<h3 id="Unchecked-Exception"><a href="#Unchecked-Exception" class="headerlink" title="Unchecked Exception"></a>Unchecked Exception</h3><p>Unchecked Exception的发生有一部分是因为开发者的代码逻辑错误造成的，比如<code>NullPointerException</code>这种可以通过检查是否为null来避免的异常。</p>
<p>但是也有一部分跟开发者没关系，它们是<code>java.lang.Error</code>的子类，我们不能够预料这部分异常的发生，所以并<strong>不强制</strong>我们对其进行处理，但如果不捕获，在运行期间如果发生异常就会中断程序的执行。比如<code>OutOfMemoryError</code>可能发生在任意一个实例对象创建的时候，但我们不可能在每个实例对象创建的时候都使用<code>catch</code>语句去捕获异常。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面的例子，由于我们没有对Checked Exception进行处理而导致编译失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使上面的代码可以正确编译，我们可以在<code>try/catch</code>块中捕获相应的异常，或者使用<code>throws</code>在main方法声明处抛出异常。</p>
<p>但是如果在main方法内部抛出一个Unchecked Exception，依然可以正确编译，如下面的例子，这是因为Unchecked Exception无法在编译期间被发现，所以即使不处理也能够正常编译。这点在IDE中也可以直接看到效果，如果是能够在编译期间被发现的异常，IDE会有所提示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exception类层次结构"><a href="#Exception类层次结构" class="headerlink" title="Exception类层次结构"></a>Exception类层次结构</h3><p><code>java.lang.Throwable</code>类是一个Checked Exception，它有两个子类：<code>java.lang.Exception</code>和<code>java.lang.Error</code>，Error类是Unchecked Exception，Exception类则是Checked Exception</p>
<p>。</p>
<p>Exception类有一个Unchecked Exception子类：<code>java.lang.RuntimeException</code>，像<code>NullPointerException</code>和<code>ClassCastException</code>都是RuntimeException的子类。RuntimeException和Error的所有子类都是Unchecked Exception，其他的则都是Checked Exception，如下图所示。</p>
<p><img src="/2020/07/15/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/exception-class-hierarchy.png" alt="exception-class-hierarchy"></p>
<p>如果我们自定义一个异常类，那它是Checked Exception还是Unchecked Exception取决于其父类的类型。在对Checked Exception进行catch操作时，需要遵循一定的规则：在catch块中捕获的异常，必须在try块中有出现这种异常的可能性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(java.io.IOException ioe) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子并不能编译成功，这是因为在try块中永远不会抛出IOException。但如果catch块中捕获的是一个Unchecked Exception，那么就不会有这种问题，因为编译器不能检查出Unchecked Exception，那么它倾向于认为catch块中的捕获是能够捕获到的。</p>
<p>Exception和Throwable这两个类比较特殊，虽然它们都是Checked Exception，但是我们依然可以在catch块中捕获它们，即使它们并没有在try块中抛出异常的可能性，比如下面的代码就能够正常编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exception和Throwable之所以比较特殊是因为它们这两个类都有Unchecked Exception类型的子类，所以编译器允许我们捕获它们（编译器认为我们在捕获的是Unchecked Exception）。</p>
<h3 id="JVM和程序异常"><a href="#JVM和程序异常" class="headerlink" title="JVM和程序异常"></a>JVM和程序异常</h3><p>JVM Exception是由JVM自己抛出的异常。例如，我们调用null对象的方法时，JVM会抛出<code>NullPointerException</code>,或者出现10除以0的情况时，JVM会抛出<code>ArithmeticException</code>，这些异常都是由JVM自动抛出的。</p>
<p>除了JVM异常，其他的都是程序异常。我们可以显式使用<code>throw</code>抛出异常，比如<code>NumberFormatException</code>可能被方法<code>Integer.parseInt</code>或<code>Float.parseFloat</code>抛出，都是程序异常，我们可以在Integer类的parseInt方法的实现中找到以下声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM不会主动抛出这种类型的异常（程序异常），这些异常都是在程序中使用<code>throw</code>显式抛出，当然也可以在程序中显式抛出JVM Exception，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"I told you s shouldn't be null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但通常来说，JVM Exception是不会被开发者抛出的，一般由JVM自己主动抛出，所有的JVM Exception都是Unchecked Exception，而程序异常则可能是Checked Exception或Unchecked Exception。</p>
<h3 id="争论"><a href="#争论" class="headerlink" title="争论"></a>争论</h3><p>关于Checked Exception和Unchecked Exception其实争论是比较大的，Checked Exception的本意是在编译时检查是否存在异常处理程序，强制开发者对异常进行处理，从而减少未正确处理的异常数量。但是，也有观点支持Unchecked Exception，认为沿调用栈向上传播的Checked Exception破坏了顶层的方法，因为这些方法必须声明抛出所有它们调用的方法抛出的异常，而且过多的try/catch块并不能提高开发者的工作效率，还影响代码可读性，Unchecked Exception可以将异常处理集中在少数几个类进行处理，减少无用的try/catch代码块。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Checked Exception必须被显式地捕获或者抛出，而Unchecked Exception则可以不必捕获或抛出。两者从功能的角度来看是等价的，并不存在哪个更强大，选择哪个的原因更多还是看个人习惯或者组织规定问题。    </p>
<br>

<p>参考：</p>
<p>1、<a href="http://www.hacktrix.com/checked-and-unchecked-exceptions-in-java" target="_blank" rel="noopener">Checked and Unchecked Exceptions in Java</a></p>
<p>2、<a href="https://blog.csdn.net/kingzone_2008/article/details/8535287" target="_blank" rel="noopener">Java异常：选择Checked Exception还是Unchecked Exception?</a></p>
<p>3、<a href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-11.html#jls-11.2" target="_blank" rel="noopener">Compile-Time Checking of Exceptions</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
</search>
